\documentclass[envcountsame,orivec,oribibl]{llncs}
\usepackage{mathtools}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{mypackage}
\usepackage{hyperref}
%\usepackage{amsthm}

% \newtheorem{theorem}{Theorem}[section]
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{corollary}[theorem]{Corollary}
% \theoremstyle{definition}
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{example}[theorem]{Example}
% \theoremstyle{remark}

\let\doendproof\endproof
\renewcommand\endproof{~\hfill\qed\doendproof}

\newcommand{\pcolon}{\mathpunct{\,:\subseteq}}

\title{Small complexity classes for computable analysis}
\author{Akitoshi Kawamura\qquad\qquad Hiroyuki Ota}
\institute{University of Tokyo}

\pagestyle{plain}
\begin{document}

\maketitle

\begin{abstract}
Type-two Theory of Effectivity (TTE) gives a concrete and general framework for 
Computable Analysis. 
To refine it to polynomial-time computability 
while keeping as much generality as possible, 
Kawamura and Cook recently proposed a modification to TTE using 
machines that have random access to an oracle and 
run in time depending on the ``size'' of the oracle. 
They defined type-two analogues of 
$\classP$, $\classNP$, and $\classPSPACE$ 
and showed some typical operators in analysis
to belong to and be complete for these classes. 
We further refine their model and study computation below $\classP$: 
type-two analogues of 
the classes $\classL$, 
$\classNC$, 
and $\classP$-completeness under log-space reductions.
The basic idea is 
to use second-order polynomials as resource bounds, 
as Kawamura and Cook did, 
but we need to make some nontrivial (yet natural, as we will discuss) choices
when formulating small classes: 
we use a modification of the constant stack model 
of Aehlig, Cook and Nguyen for query tapes 
in order to achieve 
sufficient oracle accesses without interfering with space bounds; 
representations need to be chosen carefully, as 
computational equivalence between representations is now finer; 
uniformity of circuits must be defined 
with varying sizes of oracle gates taken into account. 
As prototypical applications, 
we recast several facts (some in a stronger form than was known) 
about the complexity of numerical problems 
into our framework. 
\end{abstract}

\section{Introduction}

Computable Analysis 
\cite{ko1991complexity,weihrauch00:_comput_analy}
studies problems 
involving real numbers, real functions and other objects in analysis
from the viewpoint of computability on digital machines. 
Elements of uncountable sets (such as real numbers) are
represented through approximations (such as sequences of rational numbers)
and processed by Turing machines. 
Such approximation can be 
presented to the machine 
as infinite strings on the tape 
or as query-answering oracles (i.e., functions taking strings to strings), 
and this choice does not make much difference 
as long as we only discuss computability. 
But when we want to pay attention to bounds on time and space, 
Kawamura and Cook \cite{kawamura2012complexity} recently pointed out that 
it is more convenient to use oracles with random access, 
and moreover, to allow the running time 
to depend on the ``size'' of the oracle. 
Employing \emph{type-two complexity theory} and 
using \emph{second-order polynomials} to bound time and space, 
they formulated analogues of complexity classes 
$\classP$, $\classNP$, $\classPSPACE$ and 
applied them to real functions and operators. 

One benefit of this was
a greater variety of objects for which we can define complexity. 
For example, with the second-order formulation
we can define a canonical representation of the space $\classC [0, 1]$
of continuous real functions, 
so that we can discuss the complexity of an
operator $F \colon \classC [0, 1] \to \classC [0, 1]$. 
This extends the previously accepted notion of 
complexity of $f \in \classC [0, 1]$
(which had been possible to formulate also in the infinite string model)
in a natural way, so that many known non-uniform results of the form
\begin{quote}
 if $f$ is in the complexity class $X$,
 then $F(f)$ is in the class $Y$, and \\
 there is $f$ in $X$ such that $F(f)$ is hard for
 the complexity class $Z$, 
\end{quote}
can now be transformed into a stronger, uniform statement of the form
\begin{quote}
 $F$ is in the complexity class $\mathcal Y$, and \\
 $F$ is hard for $\mathcal Z$ under the $\mathcal X$ reduction,
\end{quote}
where $\mathcal{X, Y, Z}$ are type-two classes analogous to ${X, Y, Z}$ 
(see \cite{kawamura2012complexity} for more details).

We continue their research and proceed down into $\classP$. 
In Section~\ref{section:small-classes}, 
we formulate and study analogues of 
$\classL$ (logarithmic space), 
$\classNC$ (poly-logarithmic depth circuits; efficiently parallelizable), 
and 
$\classP$-completeness (inherently sequential). 
While the most basic idea, 
i.e.\ that of using of second-order polynomials as resource bounds, 
is common to \cite{kawamura2012complexity}, 
there are several choices that we need to make carefully
in implementing this idea, 
due to the subtleties pertaining to small complexity classes. 
In particular, 
we use a modified version of 
the \emph{constant stack machine} \cite{aehlig2007relativizing}, 
since it is consistent with relativized circuit complexity classes 
and it makes some elemental operation log-space computable.
Formulation of uniform circuit family
also requires careful consideration to 
accommodate function oracles. 

In Section~\ref{section:applications}, 
we apply this framework to several problems in analysis.
We present several examples of real functions and operators 
that are already essentially known (but non-trivially) to be, 
in our terminology, 
in $\classL$ and $\classNC$. 
We then take up
Hoover's theorem about fixed points of contractions \cite{hoover1991real}
and Ko's theorem about inverting a function \cite{ko1991complexity}, 
which both state hardness for $\classP$ in a sense, 
and reformulate them into our framework
as stronger uniform statements (as mentioned above).


%Chap.~\ref{chapter:computable-analysis} introduces Type-two Theory of Effectivity, the framework of Computable Analysis.
%We review basic concepts of TTE in Sect.~\ref{section:TTE} and
%Kawamura's extended framework for TTE in Sect.~\ref{section:TTF}.
%In Sect.~\ref{section:small-classes}, we introduce our new type-two classes
%$\classLtwo$ and $\classNCtwo$.
%We also define $\classPtwo$-completeness under reductions using these small classes.
%In Chap.~\ref{chapter:applications}, we investigate the complexity of some analytic problems.
%In Sect.~\ref{section:function}, we prove that finding roots of a polynomial 
%from coefficients is $\classNC$ computable.
%In Sect.~\ref{section:P-complete}, we show the $\classP$-completeness of 
%the inverse operation and the fix-point operation.
%In Sect.~\ref{section:differentiable}, we study the complexity of
%smooth differential equations.
%Most part in that section only depends on Sect.~\ref{section:TTE}
%since we mainly discuss in non-uniform way.
%We summarize this thesis and discuss about future works in Chap.~\ref{chapter:conclusion}.


\paragraph{Notation}
Let $\N$ and $\R$ denote the set of nonnegative integers and 
real numbers, respectively.

When we talk about polynomials as bounds on time or space, 
we tacitly assume that they are increasing functions. 

A {\em multi-valued function} (or {\em multi-function}) $F$ from $X$ to $Y$,
denoted $F \pcolon X \rightrightarrows Y$,
is a triple $(X, R, Y)$, where $R$ is a subset of $X \times Y$.
For $x \in X$, we write $F[x]$ for the set of $y \in Y$ such that $(x,y) \in R$.
The domain of $F$, denoted by $\dom F$, is the set of $x \in X$ such that 
$F[x]$ is not empty.
If $F[x]$ has only one element, we write $F(x)$ for the unique element.
We say $F$ is a {\em partial function} if $F[x]$ has exactly one element for all
$x \in \dom F$.
We call $F$ a {\em total function} or simply a {\em function} 
if $F$ is a partial function and $\dom F = X$.

% The composition of multi-functions $F \pcolon X \rightrightarrows Y$ and 
% $G \pcolon Y \rightrightarrows Z$, denoted $F \circ G$, is a multi-function
% $(X, R, Z)$ such that $(x, z) \in R$ if and only if there is $y \in Y$ 
% satisfying that $y \in F[x]$ and $z \in G[y]$.

\section{TTE with second-order polynomials}
\label{section: computable analysis}

We review the Type-two Theory of Effectivity (TTE), 
the framework for computable analysis, 
as extended by 
\cite{kawamura2012complexity}. 
In usual discrete settings, we encode countable sets in strings, such as
natural numbers, formulas, graphs and so on. 
Likewise, 
we use string functions to 
encode uncountably many objects, such as real numbers and real functions, 
and use \emph{oracle Turing machines} (henceforth just \emph{machines}) 
to work on them.
Sect.~\ref{section:TTF} defines polynomial-time computability on 
these string functions, 
and Sect.~\ref{subsection: representations} explains how to 
apply it to real functions (and other objects) through representations. 

\subsection{Second-order polynomials}
\label{section:TTF}

A (total) function $\phi \colon \Sigma^* \to \Sigma^*$ is \emph{length monotone}
if $|\phi(u)| \le |\phi(v)|$ whenever $|u| \le |v|$.
The set of length monotone functions is denoted $\LM$.
Let $M$ be a machine and $\phi \in \LM$. 
We write $M ^\phi (u)$ for the output string 
when $M$ is given
$\phi$ as oracle and string $u$ as input.
Thus, we also regard $M^\phi$ as a function from strings to strings.

\begin{definition}
 A machine $M$ computes a multi-function $A \pcolon \LM \rightrightarrows \LM$ if for any
 $\phi \in \dom A$, there is $\psi \in A[\phi]$ such that $M^\phi(u) = \psi(u)$ for all $u \in \Sigma^*$.
\end{definition}

The \emph{size} of a length monotone $\phi$, denoted $|\phi|$,
is a (non-decreasing) function from $\N$ to $\N$ defined by 
$|\phi|(|u|) = |\phi(u)|$.
This is well-defined since a length monotone function maps 
strings of the same length to strings of the same length.

\emph{Second-order polynomials} in type-1 variable $L \colon \N \to \N$
and type-0 variable $n \in \N$ 
are defined inductively as follows:
a positive integer is a second-order polynomial;
the variable $n$ is a second-order polynomial;
$P+Q$, $P \cdot Q$ and $L(P)$ are
second-order polynomials if $P$ and $Q$ are second-order polynomials.
Note that if $P$ is a second-order polynomial and $L$ is a (usual) first-order
polynomial, then $P(L)$ is a first-order polynomial.

\begin{definition}
 We write $\classFPtwo$ for the class of
 multi-functions from $\LM$ to $\LM$ 
 computed by a machine that runs
 in second-order polynomial time.
\end{definition}

\begin{lemma}
 Functions in $\classFPtwo$ map 
 length-monotone functions in $\classFP$ to $\classFP$.
\end{lemma}

We define the paring function, denoted by $\langle \phi, \psi \rangle$,
of length-monotone functions as follows: 
% \footnote{%
% The pairing function was
% defined erroneously in \cite{kawamura2012complexity} 
% without the delimiter $1$. 
% }
$\langle \phi, \psi \rangle(0u) = \phi(u) 10^{|\psi(u)|}$ and 
$\langle \phi, \psi \rangle(1u) = \psi(u) 10^{|\phi(u)|}$.
We pad $0$s to make the pairing function length-monotone.
We write $\langle \phi, \psi, \theta \rangle$ 
for $\langle \phi, \langle \psi, \theta \rangle \rangle$, and so on.
We also write $\langle \phi, u \rangle$, etc., for 
$\phi \in \LM$ and a string $u \in \Sigma ^*$, 
where we encode $u$ as a constant function in $\LM$ with value $u$. 

\subsection{Representations}
\label{subsection: representations}

A {\em representation} of a set $X$ 
is a partial function $\delta$ from $\LM$ to $X$
such that for every $x \in X$ there is $\phi$ with $\delta (\phi) = x$.
We say $\phi$ is a {\em $\delta$-name} of $x$
if $x = \delta(\phi)$.

Let $\mathcal C$ be a class of multi-functions from $\LM$ to $\LM$,
and $\delta$ and $\gamma$ be representations of sets $X$ and $Y$, respectively.
A multi-function $A \pcolon X \rightrightarrows Y$
is $(\delta, \gamma)$-$\mathcal C$-\emph{computable} if 
the following multi-function $\delta^{-1} \circ A \circ \gamma \pcolon \LM \rightrightarrows \LM$ is in $\mathcal C$: 
\begin{equation}
 (\delta^{-1} \circ A \circ \gamma)[\phi] = 
  \begin{cases}
   \{\psi \in \dom \delta \mid \delta(\psi) \in A[\gamma(\phi)] \}
   & 
   \text{if } \phi \in \dom \gamma, 
   \\ 
   \emptyset 
   &
   \text{otherwise.}
  \end{cases}
\end{equation}

For the (basic) representations of real numbers and real functions,
we use $\rhoR$ and $\deltabox$, 
defined as follows \cite{kawamura2012complexity}.
We first introduce an encoding system of dyadic numbers.
For each $n \in \N$, let $\D_n$ denote the set of strings of the form
\begin{equation}
 sx/1\!\underbrace{00\dots0}_{n},
\end{equation}
where $s$ is the sign and $x \in \{0,1\}^*$.
We write $\D$ for the union $\bigcup _n \D _n$.
We regard $u \in \D$ as a fraction of binary numbers, 
and write $u$ also for the number it encodes. 

A function $\phi \in \LM$ is a $\rhoR$-name of $x \in \R$ 
if $\phi(0^i) \in \D$ and $\lvert \phi(0^i) - x \rvert \le 2^{-i}$
for all $i \in \N$.
We write $\rhoR|^{[0,1]}$ for the restriction of $\rhoR$ to real numbers in $[0,1]$.

The class of polynomial-time computable functions from $[0,1]$ to $\R$ 
defined by Ko is equal to
$(\rhoR|^{[0,1]},\rhoR)$-$\classFPtwo$-computable functions.
Polynomial-time computability of a real function $f$ means that
for any $x \in \dom f$ and $n,m \in \N$, 
if $|x| \le 2^m$, then
an approximation of $f(x)$ with error bound $2^{-n}$
is computable in time polynomial in $n$ and $m$.

By the time the machine outputs the approximation of $f (x)$ of precision~$2 ^{-n}$, 
it knows $x$ only with some precision $2 ^{-m}$.
This implies that all computable real functions are continuous.
If the machine runs in polynomial time,
this $m$ is bounded polynomially in $n$.
This implies \eqref{eq:modulus} in the following lemma, 
which characterizes polynomial-time real functions
by the usual polynomial-time computability of string functions 
without using oracle machines. 

\begin{lemma}
 \label{lem:type1representation}
 A real function is polynomial-time computable if and only if
 there exist a polynomial-time computable function 
 $\phi \colon (\D \cap [0, 1]) \times \{0\} ^* \to \D$ and 
 polynomial $p \colon \N \to \N$ such that
 for all $d \in \D \cap [0,1]$ and $n \in \N$,
 \begin{equation}
   \label{eq:computation on rational points}
  |\phi(d, 0^n) - f(d)| \le 2^{-n},
 \end{equation}
 and for all $x, y \in [0, 1]$, $n \in \N$,
 \begin{equation} 
  |x-y| \le 2^{-p(n)} \Rightarrow |f(x) - f(y)| \le 2^{-n}.
   \label{eq:modulus}
 \end{equation}
\end{lemma}

We say $\mu \colon \N \to \N$ is a {\em modulus of continuity} of $f \in \classC[0,1]$
if $|x - y| \le 2^{-\mu(n)} \Rightarrow |f(x) - f(y)| \le 2^{-n}$ for all $x, y \in [0,1]$ and $n \in \N$.
The following representation $\deltabox$ that we will use for real functions in $\classC[0,1]$ 
is inspired by this. 

For a non-decreasing function $\mu \colon \N \to \N$, 
we write $\overline \mu \colon \Sigma^* \to \Sigma^*$ for the length-monotone
function mapping $u$ to $0^{\mu(|u|)}$ for each string $u$.
For $\phi \in \LM$ and $\mu \colon \N \to \N$ non-decreasing,
we say that $\langle \overline{\mu}, \phi \rangle$ is a $\deltabox$-name of $f \in \classC[0,1]$
if $\mu$ is a modulus of continuity of $f$
and $\phi$ satisfies \eqref{eq:computation on rational points}
for all $n \in \N$ and $d \in \D|_{[0,1]}$.

Lemma~\ref{lem:type1representation} implies that
$(\rhoR|^{[0,1]},\rhoR)$-$\classFPtwo$-computability is equivalent to 
$\deltabox$-$\classFP$-computability,
where \emph{$\gamma$-$C$-computability} by definition means 
having a $\gamma$-name in $C$.


\section{Small type-two classes}
\label{section:small-classes}

In this section, we introduce new type-two complexity classes
corresponding to log-space $\classL$ and circuit complexity $\classNC$
based on the framework we reviewed in the previous section.
We also define $\classP$-completeness under log-space reductions.

\subsection{Logarithmic space}
There are several non-equivalent definitions of 
relativized log-space computation
\cite{aehlig2007relativizing,buss1988relativized,ladner1976relativization,wilson1988measure}.
Here, we define type-two log-space computation 
by extending the {\em stack model with constant height} 
by Aehlig, Cook and Nguyen \cite{aehlig2007relativizing} to the 
function-oracle model.
We choose this model because it is consistent with relativized circuit complexity classes, 
and it can ask nested queries, that is, queries depending on answers to previous queries.
See also the comments on Theorems \ref{theorem:inclusion} and \ref{theorem:apply-is-L-computable}.

We consider an oracle Turing machine $M$ 
with a stack of query tapes and an answer tape.
The machine $M$ can write a symbol on the top query tape, or 
\emph{push} a new query tape on the top of the stack (and start writing on it).
When the machine issues a query, the stack is \emph{popped} automatically; 
that is, 
if the string on the query tape at the top of the stack was $u$, 
the oracle $\phi$ writes the string $\phi (u)$ on the answer tape, 
and at the same time the top query tape is removed from the stack. 
We put the restriction that the height of the stack of a machine is less than 
some constant for all inputs and oracles.
We also assume that 
the answer tape is erased after each push operation.

The use of a stack of query tapes and its restriction to constant height 
is common to Aehlig, Cook and Nguyen \cite{aehlig2007relativizing}. 
As we are dealing with function oracles, 
our model has some new features, namely 
the introduction of answer tape and 
the restriction that it is erased automatically on every puch operation. 

This erasure of the answer tape
ensures that the nested depth of queries is restricted to a constant.
Without this restriction, a log-space constant-stack machine relative to 
a function oracle $\phi$ could compute polynomial-times composition
of $\phi$ if $|\phi|(n) = n$.
On the other hand, there is a function $\phi \in \LM$ such that $|\phi|(n) = n$
and polynomial-times composition of $\phi$ is not in $\classNC$ relative to $\phi$ \cite{aehlig2007relativizing}.
Hence, the inclusion between $\classL$ and $\classNC$ would not be relativized.



\begin{definition}
 A (constant-stack) machine $M$ runs in (second-order) \emph{logarithmic space}
 if there is a second-order polynomial $P$ such that for all $\phi \in \LM$
 and $u \in \Sigma^*$, $M^\phi(u)$ visits at most $\log(P(|\phi|)(|u|))$ cells
 in the work tape.
\end{definition}

\begin{definition}
 We write $\classFLtwo$ for the set of multi-functions%
\footnote{%
We could also define a class $\classLtwo$, 
analogous to $\classPtwo$ in \cite{kawamura2012complexity}, 
of multi-functions whose values are functions in $\LM$ 
that are $\{0, 1\}$-valued, 
but we will not use such classes in this paper. 
}
 from $\LM$ to $\LM$ 
 computed by a constant-stack machine that runs in second-order logarithmic space.
\end{definition}

\begin{lemma}
\label{lemma:Ltwo-maps-L-to-L}
 Functions in $\classFLtwo$ map 
 length-monotone functions in $\classFL$
 to length-monotone functions in $\classFL$.
\end{lemma}

% \begin{proof}
% For all $\phi \in \classFL$, the size of $\phi$ is bounded by some polynomial,
% hence second-order logarithm collapses to first-order logarithm.
% Since $\classFL$ is low for itself ($\classFL^\classFL = \classFL$), 
% functions computed by log-space constant-stack machines with $\classFL$ oracle are in $\classFL$.
% \end{proof}

\subsection{Circuit complexity classes}

To discuss type-two circuit complexity classes,
we consider circuit families with oracle gates.
Let $n, m \in \N$ and $L \colon \N \to \N$ be a non-decreasing function.
An \emph{$n$-input $m$-output circuit with size-$L$ oracle gates} is a circuit with
$n$ inputs and $m$ outputs consisting of the standard logical gates 
plus oracle $(\phi)$ gates, 
where each $\phi$ gate with $k$ inputs has $L(k)$ outputs.
Formally, 

\begin{definition}[Oracle circuits]
Let $n, m \in \N$ and $L \colon \N \to \N$ be a non-decreasing function.
A \emph{$n$-input $m$-output circuit with size-$L$ oracle gates} is 
a labeled directed acyclic graph with $n$ sources and $m$ sinks.
All vertices except the sources are labeled with $\NOT$, $\OR$, $\AND$ 
or $\phi _i$, where $i \in \N$.
The in-degree of a vertex labelled $\NOT$ is $1$, and
a vertex that is labelled $\phi _i$ and has in-degree $k$ 
satisfies $i < L(k)$.
Each logic gate performs the logical operation on its inputs
and $\phi_i(x) = 1$ if and only if the $i$th bit of $\phi(x)$ is $1$.

The size of $C$, denoted by $|C|$, is the number of vertices.
The depth of $C$, denoted by $\depth(C)$, is the length of the longest path in $C$.
For an input $x \in \{0, 1\}^*$, an oracle $\phi \in \LM$, 
and a $|x|$-input $m$-output circuit $C$ with size-$|\phi|$ oracle gates, 
we write $C^\phi(x)$ for the output of $C$.
\end{definition}


Now we define type-two classes analogous to 
$\classAC^i$ and $\classNC$.
To discuss circuit families computing multi-functions from $\LM$ to $\LM$,
we index circuits not only by the input size but also by the size of oracle gates.
A {\em circuit family $(C_{L,n})_{L,n}$} is a set of circuits, 
indexed by numbers $n \in \N$ and non-decreasing functions $L \colon \N \to \N$,
such that $C_{L, n}$ is an $n$-input circuit with size-$L$ oracle gates.


\begin{definition}
 We say that a a circuit family $(C_{L,n})_{L,n}$ 
\emph{computes} a multi-function 
 $A \pcolon \LM \rightrightarrows \LM$ if for all $\phi \in \dom A$, 
 there is $\psi \in A[\phi]$ satisfying $\psi(x) = C_{|\phi|, |x|}^\phi(x)$
 for all $x \in \Sigma^*$.
\end{definition}

Now we want to define the type-two complexity class analogous to $\classNC$.
To define it, we choose not $\classNC^i$ but $\classAC^i$ 
only for the sake of simplicity.

A circuit family $(C_{L,n})_{L,n}$ is \emph{(second-order) polynomial size}
if there is a second-order polynomial $P$ satisfying
$|C_{L,n}| \le P(L)(n)$ for all $n \in \N$ and non-decreasing functions
$L \colon \N \to \N$.

\begin{definition}
 For each $k \in \N$, 
 we write $\classFACtwo^k$ for the class of 
 multi-functions from $\LM$ to $\LM$ computed by
 a polynomial-size circuit family $(C_{L,n})_{L,n}$ such that
 there is a second-order polynomial $P$ satisfying
 $\depth(C_{L,n}) \le \log^k(P(L)(n))$ 
 for all $n \in \N$ and non-decreasing
 $L \colon \N \to \N$.
 We write $\classFNCtwo = \bigcup_{k \in \N} \classFACtwo^k$.
\end{definition}

Next, we want to define log-space uniformity in oracle circuit families.
Since an oracle circuit family is indexed by the size of the input and the oracle gate,
a function computing (descriptions of) circuits needs both sizes.

\begin{definition}[uniformity]
A circuit family $(C_{L,n})_{L,n}$ is \emph{$\classLtwo$-uniform} if there is a function $A \in \classFLtwo$ 
such that for all $n \in \N$ and non-decreasing $L \colon \N \to \N$, 
the string $A (\overline L) (0^n)$ is (a description of) $C_{L,n}$. 
%% 「description」とは？？？
\end{definition}

Hereafter, we assume log-space uniformity on all (type-one and type-two) 
circuit complexity classes, so we write just ``uniform'' or omit ``$\Luniform$''.

\begin{theorem}
\label{theorem:P-equals-L-uniform-P-poly}
A multi-function $A$ from $\LM$ to $\LM$ is computed by a polynomial-size
uniform circuit family if and only if $A \in \classFPtwo$.
\end{theorem}

\begin{proof}
 It is obvious that machines can compute the output of
 polynomial-size uniform circuits in polynomial time.
 The if part is proved in the similar argument to the proof of
 $\classP \subseteq \classP\!\text{/poly}$.
 For each multi-function $A \in \classFPtwo$, there is an oracle machine $M$
 computing $A$ whose head movements do not depend on the input $x$ or oracle
 $\phi$ but only depend on the input length $|x|$ and oracle size $|\phi|$.
 This property enable a polynomial-size uniform circuit family to simulate $M$.
\end{proof}

The relativization using the stack model by Aehlig, Cook and Nguyen preserves
the inclusion of non-relativized classes
$\classAC^0 \subseteq \classL \subseteq \classAC^1 \subseteq \classNC$.
Since we define the type-two log-space class by extending the stack model,
the analogous inclusions can be shown for our type-two classes
by a similar argument. 

\begin{theorem}
\label{theorem:inclusion}
$ \classFACtwo^0
 \subseteq \classFLtwo 
 \subseteq \classFACtwo^1
 \subseteq \classFNCtwo
 \subseteq \classFPtwo$. 
\end{theorem}

\begin{proof}
 The first inclusion can be proved in a similar way
 to $\classAC^0 \subseteq \classL$.
 The second inclusion can be proved in a similar argument to 
 the proof of $\text{cs}\classL(\alpha) \subseteq \classAC^1(\alpha)$
 \cite{aehlig2007relativizing}.
 The third inclusion immediately follows from the definition.
 The forth inclusion follows from Theorem~\ref{theorem:P-equals-L-uniform-P-poly}.
\end{proof}


The following lemma states that type-two $\classLtwo$ uniformity respects
$\classL$ uniformity.

\begin{lemma}
\label{lemma: respects uniformity}
 Let $(C_{L,n})_{L,n}$ be a (second-order) polynomial-size $\Luniform$ oracle circuit family
 and $(D_n)_n$ be a (first-order) polynomial-size $\classL$-uniform circuit family.
 A circuit family given by replacing oracle gates in $(C_{L,n})_{L,n}$ with
 $(D_n)_n$ is $\classL$-uniform.
\end{lemma}

\begin{corollary}
\label{corollary: type-one and type-two circuit classes}
\begin{enumerate}
 \item Functions in $\classFACtwo^i$ 
       map length-monotone functions in $\classFAC^j$ 
       to $\classFAC^{i+j}$.
 \item Functions in $\classFNCtwo$
       map length-monotone functions in $\classFNC$ 
       to $\classFNC$.
\end{enumerate}
\end{corollary}

See appendix for proofs of 
Lemma~\ref{lemma: respects uniformity} and 
Corollary~\ref{corollary: type-one and type-two circuit classes}.

\subsection{Reductions and completeness}

\begin{definition}
Let $A$ and $B$ be multi-functions from $\LM$ to $\LM$.
\begin{itemize}
 \item $A$ is \emph{many-one log-space reducible} to $B$, 
       denoted $A \redLmF B$,
       if there are functions $r, s, t \in \classFLtwo$ such that 
       for all $\phi \in \dom A$,
       $s(\phi) \in \dom B$ and each $\theta \in B[s(\phi)]$ satisfies that
       the function maps $x \in \Sigma^*$ to $r(\phi)(x, \theta(t(\phi)(x)))$
       is in $A[\phi]$.
 \item $A$ is \emph{Weihrauch log-space reducible} to $B$,
       denoted $A \redLW B$,
       if there are functions $r, s \in \classFLtwo$ such that 
       for all $\phi \in \dom A$,
       $s(\phi) \in \dom B$ and each $\theta \in B[s(\phi)]$ satisfies that
       $r(\langle \phi, \theta \rangle)$ is in $A[\phi]$.
\end{itemize}
\end{definition}

These are analogous to the polynomial-time reductions 
$\redmF^2$, $\redW^2$ in Kawamura and Cook~\cite{kawamura2012complexity}.
Note that $A \redLmF B$ implies $A \redLW B$.

There is another version of a many-one reduction defined by
Beame et al. \cite{beame1995relative}.
We define as follows a log-space reduction analogous to it:
We write $A \redLB B$ 
if there are functions $r, s, t \in \classFLtwo$ such that 
for all $\phi \in \dom A$,
$s(\phi)(x, \cdot) \in \dom B$ and each $\theta \in B[s(\phi)(x, \cdot)]$ 
satisfies that the function maps $x \in \Sigma^*$ 
to $r(\phi)(x, \theta(t(\phi)(x)))$ is in $A[\phi]$.
This reduction is much stronger than others since
it can use the input string $x$ while making the input of $B$.
The reduction $\redLmF$ is a special case of $\redLB$ where
$s$ does not depend on the string input $x$.
See the comments after the next lemma and before Theorem~\ref{theorem:P-hard-g_u} for
the disadvantage and the advantage of this reduction.

Let $\mathcal{C}$ be a class of multi-functions from $\LM$ to $\LM$
and $\leq$ be a type-two reduction.
A multi-function $B$ from $\LM$ to $\LM$ is \emph{$\mathcal{C}$-$\leq$-hard} if $A \leq B$ for all $A \in \mathcal{C}$,
and $B$ is \emph{$\mathcal{C}$-$\leq$-complete} 
if $B$ is $\mathcal{C}$-$\leq$-hard and in $\mathcal{C}$.


For $F \subseteq \LM$, 
define the multi-function $\bigcup F \pcolon \Sigma ^* \rightrightarrows \Sigma ^*$ by
$(\bigcup F) [x] = \{\, f(x) \mid f \in F \,\}$.

\begin{lemma}
\label{lemma:P-complete}
Let $B$ be a $\classFPtwo$-$\redLmF$-complete multi-function.
There is $\psi \in \dom B \cap \classFL$ satisfying that
 $\bigcup (B[\psi])$ is $\classFP$-$\le^\classL_{\mathrm{mF}}$-complete.
\end{lemma}

We will use this lemma to reduce 
non-constructive results (the existence of $\classFP$-hard solution) to
constructive results ($\classFPtwo$-$\redLmF$-hardness of an operation).
Note that this lemma does not hold for
the reductions $\redLB$; cf.~\cite[Lemma~3.6]{kawamura2012complexity}.

The following partial function $\probDTIMEtwo \pcolon \LM \to \LM$ 
is a standard complete problem: 
$\dom \probDTIMEtwo$ consists of $\langle M, \overline \mu, \phi \rangle$
such that $M$ is (the program of) a machine, 
$\mu \colon \N \to \N$ is non-decreasing, 
$\phi \in \LM$, 
and $M^\phi(x)$ stops in $\mu(|x|)$ steps for all $x \in \Sigma^*$; 
for such $\langle M, \overline \mu, \phi \rangle$, 
we define $\probDTIMEtwo(\langle M, \overline \mu, \phi \rangle)(x)$ to be 
the output of the computation $M^\phi(x)$.

\begin{lemma}
\label{lemma: probDTIMEtwo}
 $\probDTIMEtwo$ is $\classFPtwo$-$\redLmF$-complete.
\end{lemma}

% We define a partial function  $\probCVPtwo \pcolon \LM \to \LM$ as follows:
% $\dom \probCVPtwo$ is the set of $\langle (C_n)_n, \phi \rangle$
% such that $C_n$ is (the description of) a circuit with $n$ inputs 
% (and multiple outputs)
% consisting of $\AND$, $\OR$, $\NOT$ and oracle gates, 
% for which $\phi \in \LM$ has the right size.
% For $\probCVPtwo(\langle (C_n)_n, \phi \rangle)(x) = C^\phi_{|x|}(x)$.

% \begin{lemma}
%  $\probCVPtwo$ is $\classFPtwo$-$\redLmF$-complete.
% \end{lemma}

% \begin{proof}
% Similar to Theorem~\ref{theorem:P-equals-L-uniform-P-poly}.
% \end{proof}

See appendix for 
proofs of Lemma~\ref{lemma:P-complete} and Lemma~\ref{lemma: probDTIMEtwo}. 

\subsection{Representations}
\newcommand{\transL}{\preceq_\classLtwo}

The following lemmas are analogous to 
those at the level of polynomial-time \cite{kawamura2012complexity}. 

\begin{definition}
Let $\gamma$ and $\delta$ be two representations of a set $X$.
We write $\gamma \transL \delta$ if
there is a function $F \in \classFLtwo$ \emph{translating} $\gamma$-names
into $\delta$-names, that is, 
$F (\phi) \in \dom \delta$ and $\delta(F(\phi)) = \gamma (\phi)$ 
for all $\phi \in \dom \gamma$.
\end{definition}

\begin{lemma}
 Let $\mathcal{C}$ be $\classFLtwo$, $\classFNCtwo$ or
 $\classFPtwo$.
 Let $\gamma$ and $\gamma'$ be two representations of a set $X$, 
 $\delta$ and $\delta'$ be two representations of a set $Y$.
 If $\gamma' \transL \gamma$ and $\delta \transL \delta'$,
 a $(\gamma, \delta)$-$\mathcal C$-computable multi-function is
 $(\gamma', \delta')$-$\mathcal C$-computable.
\end{lemma}

Let $\delta$ and $\gamma$ be representations of $X$ and $Y$, respectively.
We say that $A \pcolon X \rightrightarrows Y$ is $(\delta, \gamma)$-$\classFPtwo$-$\le$-hard 
if $\gamma^{-1} \circ A \circ \delta$ (see Section~\ref{subsection: representations}) is $\classFPtwo$-$\le$-hard.

\begin{lemma}
 Let $\gamma$ and $\gamma'$ be representations of a set $X$, 
 and let $\delta$ and $\delta'$ be representations of a set $Y$.
 If $\gamma' \transL \gamma$ and $\delta \transL \delta'$,
 then a $(\gamma, \delta)$-$\classFPtwo$-$\redLW$-hard multi-function is
 $(\gamma', \delta')$-$\classFPtwo$-$\redLW$-hard.
\end{lemma}

We say that $x \in X$ is $\gamma$-$C$-$\le$-complete if
$\bigcup(\gamma^{-1}[x])$ is $C$-$\le$-complete,
where $\gamma^{-1}[x]$ is the set of $\delta$ names $\phi \in \LM$ of $x \in X$.

\begin{lemma}
 Let $\mathcal C$ be $\classFLtwo$, $\classFNCtwo$, 
 or $\classFPtwo$, and $C$ be the type-one complexity class
 corresponding to $\mathcal C$.
 Let $\gamma$ and $\delta$ be representations of a set $X$ and a set $Y$.
 A $(\gamma, \delta)$-$\mathcal C$-computable partial function $F$ from $X$
 to $Y$ maps $\gamma$-$C$-computable elements of $X$
 in $\dom F$ to $\delta$-$C$-computable elements of $Y$.
\end{lemma}

\begin{lemma}
 \label{lemma:p-comp-maps-l-to-p-comp}
 Let $\gamma$ and $\delta$ be representations of a set $X$ and a set $Y$.
 A $(\gamma, \delta)$-$\classFPtwo$-$\redLmF$-complete partial function 
 from $X$ to $Y$ maps some $\gamma$-$\classFL$-computable element of $X$
 to a $\delta$-$\classFP$-$\redmF^\classL$-complete of $Y$.
\end{lemma}

\section{Applications}
\label{section:applications}

In Sect.~\ref{section:function}, 
we show that some examples of real functions and operators 
that are $\classL$- and $\classNC$-computable.
In Sect.~\ref{section:P-complete}, we show the $\classP$-completeness of 
the inverse operation and the fix-point operation.

\subsection{Within $\classFLtwo$ and $\classFNCtwo$}
\label{section:function}

We show several functions to be 
in $\classFLtwo$ and $\classFNCtwo$
under suitable representations. 
We start with real functions, 
using the representation $\rhoR$
(see Sect.~\ref{subsection: representations}). 
Ko's class $\mathrm{LOGSPACE}_{\classC[0,1]}$ of
\emph{log-space real functions} in $\classC[0,1]$ 
\cite{ko1991complexity} 
coincides with our $(\rhoRunit, \rhoR)$-$\classFLtwo$-computability, 
despite our choice of constant-stack log-space machine 
while Ko uses the obvious log-space oracle Turing machine 
with no stack.
This is because, 
when computing approximation of $f(x)$ under $\rhoR$-names, 
a machine can get enough information about $x \in [0,1]$ in one query.
Ko also defines the class of $\classNC$ real functions in $\classC[0,1]$
through $\deltabox$-$\classFNC$-computability in our terminology 
\cite{ko1991complexity},
which easily equals $(\rhoRunit, \rhoR)$-$\classFNCtwo$-computability.
The $\classNC$-real functions from $\R$ to $\R$ defined by Hoover \cite{hoover1991real}
are equal to $(\rhoR, \rhoR)$-$\classFNCtwo$-computable real functions.

\begin{theorem}
 \label{theorem:apply-is-L-computable}
 Let $\delta$ be a representation of $\classC[0, 1]$.
 $\OpApply$ is $([\delta, \rhoRunit], \rhoR)$-$\classFLtwo$-computable if
 and only if $\delta \transL \deltabox$.
\end{theorem}

Theorem~\ref{theorem:apply-is-L-computable} can be proved 
similarly to the analogous theorem for $\classFPtwo$ 
\cite{kawamura11:_funct_space_repres_and_polyn_time_comput}. 
Note that, 
if we had defined $\classFLtwo$ with the obvious relativized machine with one query tape,
$\classFLtwo$ would be either too weak 
for $\OpApply$ to be $([\deltabox,\rhoR], \rhoR)$-$\classFL$-computable or
too strong to be a subset of $\classFNCtwo$,
depending on whether or not the machine is allowed to look at the answer tape while writing queries.
Our extension of the constant stack model is the weakest
such that both Theorem~\ref{theorem:apply-is-L-computable} and 
$\classFLtwo \subseteq \classFNCtwo$ true.

% \begin{example}
%  The binary addition and the binary multiplication are
%  $([\rhoR, \rhoR], \rhoR)$-$\classFLtwo$-computable.
% \end{example}

\begin{lemma}
 The exponential function restricted to $[0,1]$
 is $(\rhoRunit, \rhoR)$-$\classFLtwo$-computable.
\end{lemma}
Since the series $\exp(t) = \sum_n x^n / n!$ converges fast enough,
a $2^{-m}$-approximation of $\exp(t)$ for $t \in [0,1]$ is computable 
by polynomially many multiplications, additions, and divisions on rationals.
Since iterated multiplication, iterated addition, and division on integers
are in $\classFL$ by Chiu, Davida and Litow~\cite{chiu2001division},
$\exp$ is $(\rhoRunit, \rhoR)$-$\classFLtwo$-computable.
On the other hand, without the restriction on the domain, $\exp$ is not 
even $(\rhoR, \rhoR)$-$\classFPtwo$-computable, 
because it grows too fast. 

\begin{lemma}
  The sine function $\sin \colon \R \to \R$ is
 in $(\rhoR, \rhoR)$-$\classFLtwo$.
\end{lemma}
Like $\exp$, the Taylor series of $\sin$ converges fast enough,
so it is obvious that $\sin$ is log-space computable if it is restricted to $[-4, 4]$.
Computing some $x \in [-4, 4]$ satisfying $x = t + 2n\pi$ for 
some $n \in \N$ is
$(\rhoR, \rhoR|^{[-4,4]})$-$\classFLtwo$-computable because division is log-space computable and $\pi$ is $\rhoR$-$\classFL$-computable from the following series:
\begin{equation}
 \pi = \sum_{k=0}^\infty \frac{1}{16^k} 
  \left( \frac{4}{8k+1} - \frac{2}{8k+4} - \frac{1}{8k+5} - \frac{1}{8k+6} \right).
\end{equation}
Hence, $\sin$ is $(\rhoR, \rhoR)$-$\classFLtwo$-computable.

In the rest of Sect.~\ref{section:function}, 
we reformulate in our terminology Neff's result that 
finding roots of a complex polynomial is $\classNC$ computable. 

%\paragraph{Finding polynomial roots is $\classFNCtwo$-computable}
We write $P_n$ for the set of degree-$n$ monic 
polynomials (i.e.\ the leading coefficient is $1$) with complex coefficients.
We write $\OpPolyRoot(p)$ for the multiset of all the roots of $p \in P_n$, that is, $p(x) = \prod_{z \in \OpPolyRoot(p)} (x - z)$. 

Neff first showed that approximating the roots of polynomial
with integer coefficients is in $\classFNC$.
\begin{theorem}
[NC polynomial root isolation \cite{neff1994specified}]\label{theorem:neff1994}
There is an algorithm $A$ such that,
for any choice of integers $n$, $m$, $k$, and a polynomial $p \in P_n$
with $|p| \le 2^m$,
$A$ computes $k$-digit approximation to the roots of $p$ 
in at most $C \log^e(n + m + k)$ parallel steps, 
using at most $D(n + m + k)^f$ processors, where $C, D, e, f$ are positive
constants which are independent of $n$, $m$, and $k$.
\end{theorem}
We write $|p|$ for the maximum absolute value
 of coefficients in $p$.
%and the \emph{distance} of
%two polynomials $p$, $q \in P_n$, denoted $d(p, q)$, is $|p-q|$.

Later Pan showed that approximating the roots of a polynomial
with complex rational coefficients is in $\classFNC$ \cite{pan1995optimal}.
Neff and Reif showed a similar result and they also discuss
the modulus of continuity of finding roots \cite{neff1996efficient}.

\begin{theorem}
[{\cite[Theorem 2.1]{neff1996efficient}}]
 Let $f$ and $g$ be monic polynomials of the same degree $n$,
 and let $|f| \le 2^m$.
 If $|f - g| \le 2^{\lceil n(k + m + \log n + 3)\rceil}$, then
 \begin{equation}
  d(\OpPolyRoot(f), \OpPolyRoot(g)) \le 2^{-k} 
 \end{equation}
 for all $k \in \N$.
\end{theorem}

They regard these two results ensure that $\classFNC$-computability
of finding roots of a polynomial with complex coefficients.%%??????
In our framework, we can combine these two results by stating 
$\classFNCtwo$-computability under suitable representations.

To discuss the complexity of finding roots of a polynomial,
we need representations for polynomials and multisets of complex numbers.
We represent a complex number by a pair of $\rhoR$-names,
that is, $
 \rho_\C (\langle \phi, \psi \rangle) 
= 
 \rhoR (\phi) + \sqrt{-1} \cdot \rhoR (\psi)
$.  We define the representation $\rho_{P_n}$ of 
$P _n$ as follows: 
$\phi \in \LM$ is a $\rho_{P_n}$-name of $p \in P_n$ 
if $\phi$ is a $\rho_{\C^n}$-name of $(a_{n-1}, \dots, a_0)$ 
such that $p(x) = x^n + a_{n-1}x^{n-1} + \cdots a_0$.
Define the representation $\rho_{P_*}$ of monic polynomials by
$p(x) = \rho_{P_*}(\langle 0^n, \phi \rangle) \iff p(x) = \rho_{P_n}(\phi)$.

We represent multisets of complex numbers as converging sequences of 
multisets of rational complex numbers.
The distance between two multisets $S = \{z_1, \dots, z_n\}$
and $S' = \{z'_1, \dots, z'_n\}$ is defined as
\begin{equation}
d(S, S') = \min_{\sigma} \max_{j = 1, \ldots, n}|z_j - z'_{\sigma(j)}|,
\end{equation}
where $\sigma$ ranges over all permutations on $\{1, \ldots, n\}$. 
Define the representation $\rhoCSet$ as follows:
Let $S$ be a multiset of $n$ complex numbers. 
We say that $\phi \in \LM$ is a $\rhoCSet$ name of $S$ if
for all $m \in \N$, there are $a_1, b_1, a_2, b_2, \dots, a_n, b_n \in \D_m$
such that $\phi(0^m) = ( a_1, b_1, a_2, b_2, \dots, a_n, b_n )$
and $d(S, \{a_1 + b_1 i, \dots, a_n + b_n i\}) \le 2^{-m}$.

%We can also represent multisets $S$ as vectors $z \in \C^n$
%such that $S = \{z\}$.
%More formally we define representation $\rhoCSet'$ as
%$\rhoCSet'(\phi) = \{z\}$ if $\rho_{\C^*}(\phi) = (z_1, \dots, z_n)$.
%It is easy to see that $\rhoCSet' \le_\classFLtwo \rhoCSet$,
%but the following lemma says they are not equivalent even under computability.
%\begin{lemma}
% Identity function on multisets is not $(\rhoCSet, \rhoCSet')$-computable.
%\end{lemma}
%This means that $\rhoCSet'$ is more informative than $\rhoCSet$.
%\paragraph{Finding polynomial roots is $\classFNCtwo$-computable}

\begin{theorem}
 \label{theorem:finding-roots-is-in-NC}
 $\OpPolyRoot$ is $(\rho_{P_*}, \rhoCSet)$-$\classFNCtwo$-computable.
\end{theorem}

% \begin{corollary}
%  $\OpPolyRoot$ is $(\rho_{P_n}, \rhoCSet)$-$\classFNCtwo$-computable.
% \end{corollary}

Theorem~\ref{theorem:finding-roots-is-in-NC} follows immediately from
by the following algorithm:
Given $k \in \N$ and a $\rho_{P_n}$-name of $p \in P_n$, 
compute a polynomial $q \in {P_n}$ with complex rational coefficients
satisfying $|p - q| \le 2^{\lceil n((k+2) + m + \log n + 3)\rceil}$
then find all the roots of $q$ using the algorithm by Neff and Reif, or Pan
with precision $2^{-(k+2)}$.
By rounding them, we get $2^{-k}$-approximations of all roots of $p$.

\subsection{$\classPtwo$-complete operations}
\label{section:P-complete}

Here we state and prove uniform versions of 
Hoover's and Ko's $\classP$-hardness results 
about operators on real functions. 
As mentioned in the introduction, 
this is only possible with our type-two formulation of complexity classes. 

\subsubsection{Inverting a function}

Fix $a$, $b \in \R$ with $a < b$. 
Let $M$ be the set of one-to-one functions $f \in \classC[0,1]$
whose range is $[a,b]$.
We define the function $\OpINV \colon M \to \classC [a, b]$ 
by saying that $\OpINV (f) = f ^{-1}$ is the inverse function of $f$. 

Ko proved the following non-uniform theorem about the complexity of inversion.
Recall that Ko's polynomial-time and log-space computability of a real function
is equivalent to our $(\rhoRunit, \rhoR)$-$\classFPtwo$- and $(\rhoRunit, \rhoR)$-$\classFLtwo$-computability. 

\begin{theorem}
[{\cite[Corollary 4.7 and Theorem 4.18]{ko1991complexity}}]
\label{theorem: ko inversion}
\begin{enumerate}
\item \label{enumi:ko1991-4.7}
Assume that $f \in M$ is polynomial-time computable. 
If $f^{-1}$ has a polynomial modulus of continuity, 
then $f^{-1}$ is polynomial-time computable.
\item \label{enumi:ko1991-4.18}
There is a log-space computable $f \in M$
such that $f^{-1}$ has a polynomial modulus of continuity
but $f^{-1}$ is not log-space computable
unless $\classP = \classL$.
\end{enumerate}
\end{theorem}

We define a representation $\deltaboxINV$ of $M$ as follows:
$\deltaboxINV(\langle \phi, \overline{\mu} \rangle) = f$ 
if and only if $\phi$ is a $\deltabox$-name of $f$ 
and $\mu$ is a modulus of continuity of $f^{-1}$.
We add a modulus of continuity of $f^{-1}$ to $\deltabox$
since without this information, there is no upper bound on 
the complexity of the inverse operation, 
as the following fact \cite[Theorem 4.4]{ko1991complexity} shows: 
for any recursive $x \in [0, 1]$, 
there exists a strictly increasing function $f \in \classC[0, 1]$ 
such that $f$ is polynomial-time computable and $x = f^{-1}(0)$.

The following theorem is the uniform version of Theorem~\ref{theorem: ko inversion}. 
Part~\ref{enumi:ko1991-4.7} of Theorem~\ref{theorem: ko inversion} follows from this and the fact that
functions in $\classFPtwo$ map length-monotone functions in $\classFP$ to $\classFP$.
Part~\ref{enumi:ko1991-4.18} follows from this theorem and Lemma~\ref{lemma:p-comp-maps-l-to-p-comp}.

\begin{theorem}
 \label{theorem:INV-is-P-complete}
 $\OpINV$ is $(\deltaboxINV, \deltabox)$-$\classFPtwo$-$\redLmF$-complete.
\end{theorem}

This will be proved in the appendix, 
using 
Theorem~\ref{theorem:P-hard-g_u} below. 

\subsubsection{Fixed points of contractions}

A function $g \colon K \to \R$ on a set $K \subseteq \R$
is called $q$-\emph{Lipschitz}, for $q > 0$, 
if $
\lvert g (x) - g (y) \rvert \leq q \cdot \lvert x - y \rvert
$ for all $x$, $y \in K$. 
A \emph{contraction} on $K$ is 
a function $g \colon K \to \R$ which is $q$-Lipschitz for some $q < 1$
and whose values are in $K$. 
The Banach fixpoint theorem states that 
a contraction has a fixed point and it is unique. 
Hoover's theorem about the complexity of computing the fixed point
of a contraction can be written in our terminology as follows:

\begin{theorem}
[{\cite[Theorem 4.5]{hoover1991real}}]
\label{theorem:hoover1991-4.5}
 There is a $(\rhoR, \rhoR)$-$\classFNCtwo$-computable function $f \colon \R \to \R$
 whose restriction $f|_{[2k, 2k+1]}$ is a contraction for each $k \in \N$ and
 which has the following property: 
 $\classNC = \classP$ if and only if 
 there is a function (from strings to strings) in $\classFNC$ mapping 
 a pair of a number $k \in \N$ (written in binary) and the string $0^n$
 to a $2^{-n}$-approximation of the 
 fixed point of $f |_{[2k, 2k + 1]}$. 
\end{theorem}

We now formulate another version of this theorem which 
will imply Theorem~\ref{theorem:hoover1991-4.5}
(see appendix for the proof that Theorem~\ref{theorem:P-hard-g_u} 
implies Theorem~\ref{theorem:hoover1991-4.5}). 

Let $C$ be the set of contractions on $[0, 1]$. 
We define its representation $\deltaboxCM$ by saying that 
a \emph{$\deltaboxCM$-name} of $g \in C$
is a pair $\langle \phi, q \rangle$ of 
a $\deltabox$-name $\phi \in \LM$ of $g$ 
and a dyadic number $q \in \D$ such that $g$ is $q$-Lipschitz. 
Let $\OpCMFix \colon C \to \R$ be the operation 
mapping each contraction on $[0, 1]$ to its fixed point.

\begin{theorem}
\label{theorem:P-hard-g_u}
$\OpCMFix$ is $(\deltaboxCM, \rhoR)$-$\classFPtwo$-$\redLB$-complete. 
It remains so even if $\dom \OpCMFix$ is restricted to contractions 
that are $1/2$-Lipschitz.
\end{theorem}

\bibliographystyle{plain}
\bibliography{bibliography}

\clearpage
\appendix
\section{Postponed proofs}

\subsection{Properties of circuits with oracles}

\begin{proof}[Lemma~\ref{lemma: respects uniformity}]
 Let $A \colon \LM \to \LM$ be a function computing the description of $(C_{L,n})_{L,n}$,
 $B \colon \Sigma^* \to \Sigma^*$ be a function computing the description of $(D_n)_n$, and
 $L \colon \N \to \N$ be the size of oracle $(D_n)_n$, i.e.
 the function mapping $n$ to the output length of $D_n$.
 The function $A(\overline{L})$ is in $\classFL$ since $\overline{L} \in \classFL$ and $A \in \classFLtwo$.
 Since given $A(\overline{L})$ and $B$ as oracles,
 computing the description of the circuit family given by replacing oracle
 gates in $(C_{L,n})_{L,n}$ with $(D_n)_n$ is log-space computable
 and $\classFL$ is low for itself ($\classFL^\classFL = \classFL$),
 it is log-space computable.
\end{proof}

\begin{proof}[Corollary~\ref{corollary: type-one and type-two circuit classes}]
The second statement immediately follows from the first statement.
Let $A$ be a function in $\classFACtwo^i$ and $(C_{L,n})_{L,n}$ be a circuit
family computing $A$ with $\log^i$ depth.
For all $\phi \in \classFAC^j \cap \LM$, 
the circuit family $(C^\phi_{|\phi|,n})_n$ is (first-order) polynomial size and its depth is $O(\log^i(n))$,
since there is a polynomial $p$ satisfying $|\phi|(n) \le p(n)$.
Let $(D_n)_n$ is a circuit family computing $\phi$ whose depth is $O(\log^j(n))$.
Replacing oracle gates in $(C^\phi_n)_n$ by $(D_n)_n$, 
we get a circuit family with polynomial size and $\log^{i+j}(n)$ depth
that computes $A(\phi)$.
\end{proof}

\subsection{$\classFPtwo$-complete problems}

\begin{proof}[Lemma~\ref{lemma:P-complete}]
Let $A \colon \LM \to \LM$ be the constant function mapping each $\phi \in \LM$ to \emph{Circuit Value Problem} ($\probCVP$), which is $\classFP$-complete function (in the usual sense).
Since $\probCVP \in \classFP$, $A \in \classFPtwo$.
Let $r, s, t \in \classFLtwo$ be functions which reduces $A$ to $B$
as the definition of $\redLmF$.
Choose any $\phi \in \classFL$, and it follows from Lemma~\ref{lemma:Ltwo-maps-L-to-L}
that $r(\phi), s(\phi), t(\phi) \in \classFL$.
Let $\psi = s(\phi)$, then $r(\phi)$ and $s(\phi)$ give the reduction that
$A(\phi) \redmF^\classL \cup (B[\psi])$.
Since $\probCVP$, equal to $A(\phi)$, is $\classFP$-$\redmF^\classL$-complete,
so is $\cup (B[\psi])$.
\end{proof}

\begin{proof}[Lemma~\ref{lemma: probDTIMEtwo}]
 For each $A \in \classFPtwo$, 
 there is a polynomial-time machine $M$ 
 and a second-order polynomial $P$ 
 such that $M$ computes $L$ and $P$ is its time bound. 
 Then $\probDTIMEtwo(s(\phi))(t(\phi)(u)) = M^\phi (u)$, 
 where 
 $s, t \in \classFLtwo$ are given by 
 $s(\phi) = \langle M, \overline{P(\mu)}, \phi \rangle$ and 
 $t(\phi)(u) = u$.
\end{proof}

\subsection{Function inversion and Banach fixed points}

\begin{proof}[Computability part of Theorem~\ref{theorem:INV-is-P-complete}]
We will prove hardness in Section~\ref{section:proofs-of-theorems}.
In the following, we will show that, 
given $f$ and $x$, 
it is easy to compute $f^{-1}(x)$ by using the binary search algorithm.

Suppose that a $\deltaboxINV$-name of a one-to-one function $f$ in $\classC [0, 1]$ is given. 
Since a modulus~$p$ of continuity of $f ^{-1}$ is given by this $\deltaboxINV$-name of $f$,
we only show how to compute a function $\phi$ such that 
$|f^{-1}(d) - \phi(0^n, d)| \le 2^{-n}$ for all $d \in \D \cap [a, b]$ and $n \in \N$.

Since $f$ is one to one, $f$ is either increasing or decreasing. 
We assume that $f$ is increasing (the other case is similar).
Given $d \in \D \cap [a, b]$, 
we compute a sequence  $a_0, b_0, a_1,b_1, \dots, a_{3n}, b_{3n}$ of rational numbers as follows.
Let $a_0 = 0$, $b_0 = 1$.
For each integer $i \le 3n-1$,
let $c_i = (a_i+b_i)/2$ and $d_i = \phi_f(c_i, 0^{p(i+2)})$.
If $d \ge d_i$, then $a_{i+1} = (3a_i+b_i)/4$ and $b_{i+1} = b_i$. 
Otherwise, let $a_{i+1} = a_i$ and $b_{i+1} = (a_i+3b_i)/4$.

We prove $f(a_i) \leq d \leq f(b_i)$ by induction on $i$.
In the case $i = 0$, $f(a_i) = f(0) \le d \le f(1) = f(b_i)$.
In the case $i=j+1$, if $d \ge d_j$ then $d \le f(b_j) \le f(b_{j+1})$ and
\begin{equation}
 d \ge d_j \ge f(c_n) - 2^{-p(j+2)} > f(a_{j+1}),
\end{equation}
where the last inequality follows from the fact that $c_j - a_{j+1} = (3/4)^i/4 > 2^{-(j+2)}$ and $p$ is a modulus of continuity of $f^{-1}$.
If $d \le d_j$ then $f(a_{j+1}) = f(a_j) \le d$ and 
\begin{equation}
 d \le d_j \le f(c_n) + 2^{-p(j+2)} < f(b_{j+1}).
\end{equation}

Let $\phi(0^n, d) = a_{3n}$.
Since $|b_{3n} - a_{3n}| = (3/4)^{3n} \le 2^{-n}$ and
$a_{3n} \le f^{-1}(d) \le b_{3n}$,
$|f^{-1}(d) - \phi(0^n, d)| \le 2^{-n}$
\end{proof}

\begin{proof}
[Theorem~\ref{theorem:hoover1991-4.5}]
 Let $A \colon \LM \to \LM$ be the constant function mapping each $\phi \in \LM$ to $\probCVP$, which is $\classFP$-complete function.
 Since  $A$ is in $\classFPtwo$ and $\OpCMFix$ is $(\deltaboxCM, \rhoR)$-$\classFPtwo$-$\redLB$-complete, $A \redLB (\rhoR^{-1} \circ \OpCMFix \circ \deltaboxCM)$.
 Let $r,s,t \in \classFLtwo$ be the reduction from $A$ to $\OpCMFix$,
 and $\phi$ be some function in $\classFL$.
 Then, $r(\phi)$, $s(\phi)$, and $t(\phi)$ are in $\classFL$ and
 $s(\phi)(u, \cdot)$ is a $\deltaboxCM$-name of a contraction on $[0,1]$ 
 for each $u \in \Sigma^*$.
 Let $(g_u)_u$ be a family of contractions on $[0,1]$
 such that $s(\phi)(u, \cdot)$ is $\deltaboxCM$ name of $g_u$.
 Define $f$ as follows: for each $u \in \Sigma^*$ and $y \in [0, 1]$,
 \begin{equation}
  \label{eq:def-f}
 f(t_u + y) = t_u + g_u(y)
 \end{equation}
 where $t_u = \overline{1u0}-2$, 
 and $f$ is connected linearly in other interval.

 We show that $f$ meets the conditions in Theorem~\ref{theorem:hoover1991-4.5}.
 This $f$ is $(\rhoR, \rhoR)$-$\classFNCtwo$-computable since 
 $|f(x) - f(x')| \le 3|x-x'|$ and $s(\phi)$ is in $\classFNC$.
 Since $g_u$ is a contraction, so is $f|_{[2n, 2n+1]}$.
 If $\classNC = \classP$,
 fix-points of $f$ on $[2n, 2n+1]$ 
 is $\classFNC$-computable since $\classFPtwo$-computable function 
 $\OpCMFix$ maps $\classFP$-computable functions into $\classFP = \classFNC$.
 The string function $r(\phi), t(\phi) \in \classFL$ many-one reduces
 $\probCVP$ to the fix-points of $(g_u)_u$.
 Hence $\classNC = \classP$ if fix-points of $f$ on $[2k, 2k+1]$ is $\classFNC$-computable.
\end{proof}

\subsubsection{$\classFPtwo$-$\redLB$-hardness of the fix-point operation}

\begin{proof}[Theorem~\ref{theorem:P-hard-g_u}]
 We show that for each $\psi \in \dom \probDTIMEtwo$
 (see Lemma~\ref{lemma: probDTIMEtwo} for the problem $\probDTIMEtwo$),
 there is a log-space computable family of contractions $(g_u)_u$ whose
 Lipschitz constant is less than $1/2$,
 and for each $u \in \Sigma^*$, $\probDTIMEtwo(\psi)(u)$ is log-space 
 computable from the fix point of $g_u$.
 Since this implies that $\probDTIMEtwo \redLB \OpCMFix$ and $\probDTIMEtwo$
 is $\classFPtwo$-$\redLmF$-hard, $\OpCMFix$ is 
 $(\deltaboxCM, \rhoR)$-$\classFPtwo$-$\redLB$-complete.

 Let $\psi \in \probDTIMEtwo$ and $\langle M, \phi, \bar \mu \rangle = \psi$.
 Let $S_i$ be the snapshot of $M^\phi(u)$ at $i$th step, then the sequence
 \begin{equation}
  S_1, S_2, \dots, S_{\mu(|u|)}.
 \end{equation}
 is the computation path of $M^\phi(u)$.
 We assume that the encoding of snapshots satisfies that 
 for some second-polynomial $P$, for all machines $M$, time functions $\mu$ 
 and inputs $u$, $|S_0| = \cdots = |S_{\mu(|u|)}| = L(\mu)(|u|)$
 regardless of the oracle $\phi$.
 Let $m = L(\mu)(|u|)$.


 For each $u \in \Sigma^*$, we define $g_u \in \classC[0,1]$ as
 a piecewise linear function with $2\mu(|u|)$ points
 $y = l_0 (=0), l_1, \dots, l_{\mu(|u|)}, r_{\mu(|u|)}, \dots, r_0(=1)$,
 where
\begin{alignat}{2}
 \label{equation: l_k}
 l_k 
 &
 = \sum_{1 \le i \le k} (2^m+\overline{S_i}) \cdot 2^{-i(m+4)+2} 
 &
 = 0.01S_100\ 01S_200 \cdots 01S_k00,
 \\
 \label{equation: r_k}
 r_k
 &
 = l^\psi_k + 2^{-i \cdot (m+4)}
 &
 = 0.01S_100\ 01S_200 \cdots 01S_k01.
\end{alignat}
 Let $S_{\mu(|u|)+1} = S_{\mu(|u|)}$ and
 define $l_{\mu(|u|)+1}$ and $r_{\mu(|u|)+1}$ as
 \eqref{equation: l_k} and \eqref{equation: r_k}.
 For each $k = 0, \dots, \mu(|u|)$,
 we define $g_u$ as
 \begin{align}
 g_u(l_k) &= l_{k+1},
 &
 g_u(r_k) &= r_{k+1}.
 \end{align}

 We show that $g_u \in \classC[0,1]$ is a contraction whose Lipschitz constant
 is less than $1/2$.
 Since $l_{k+1} - l_{k} = (2^m+\overline{S_{k+1}}) \cdot 2^{-(k+1)(m+4)+2} $
 and $r_{k+1} - r_{k} = (2^{m+4} - 2^{m+2} - 2^2 \cdot \overline{S_{k+1}} - 1)
 \cdot 2^{-(k+1)(m+4)} $,
\begin{align}
 \left|\frac{g_u(l_{k+1}) - g_u(l_k)}{l_{k+1} - l_k} \right| 
 &
 \le 2^{-m-3} \le \frac 1 2
 \\
 \left|\frac{g_u(r_{k+1}) - g_u(r_k)}{r_{k+1} - r_k} \right| 
 &
 \le 2^{-m-3} \le \frac 1 2
 \\
 \left|\frac{g_u(r_{\mu(|u|)}) - g_u(l_{\mu(|u|)})}{r_{\mu(|u|) - l_{\mu(|u|)}}} \right| 
 &
 = 2^{-m-4} \le \frac 1 2.
\end{align}
 So $|g_u(x) - g_u(y)| \le \frac 1 2 |x-y|$.

 The fix point $y^*_u$ of $g_u$ is between $l_{\mu(|u|)}$ and $r_{\mu(|u|)}$ 
 since $l_k < l_{k+1} = g_u(l_k)$ and $r_k > r_{k+1} = g_u(r_k)$.
 Let $\hat y^*_u$ be a $2^{-(m+2)\mu(|u|)}$-approximation of $y^*_u$, then
\begin{equation}
 \lfloor \hat y^*_u \cdot 2^{(m+2)\mu(|u|)-2} + 2^{-2}\rfloor  \bmod 2^m
  =
  \overline{S_{\mu(|u|)}}.
\end{equation}
 Hence, the output of $M^\phi(u)$ is log-space computable from 
 $u \in \Sigma^*$ and a $2^{-(m+2)\mu(|u|)}$-approximation $y^*_u$, and so is
 $\probDTIMEtwo(\psi)(u)$.
\end{proof}


\subsubsection{Proof of Theorems \ref{theorem:INV-is-P-complete}}
\label{section:proofs-of-theorems}

We show the $\classFP$-$\redLmF$-hardness of an operation $P$
by putting all $(g_u)_u$ into one real function $g \in \dom F$
such that for each $u \in \Sigma^*$ there is $\rhoR$-$\classFL$-computable
$t_u$ the fix point of $g_u$ is log-space computable from $h(t_u)$.

\begin{proof}
[Theorem~\ref{theorem:INV-is-P-complete}]
Let $L \in \classPtwo$ and $\psi \in \dom L$.
Let $r, s, t \in \classFLtwo$ be functions reducing $L$ to $\OpCMFix$
as Theorem~\ref{theorem:P-hard-g_u}.
Let
\begin{align}
 \lambda_n &= 2^{-2n-1},
 &
 l_u & = 1 - 2^{-|u|} + \bar u \cdot \lambda_{|u|}.
\end{align}

A unique fix point of a contraction $f(x)$ is computable as
$f^{-1}(x)$ where non-decreasing function $f$ is defined as $f(x) = x - g(x)$.
We define $g$ by transforming $g_u$ in this way, putting them into the
interval $[l_u + \frac{1}{4}\lambda_{|u|}, l_u + \frac{3}{4}\lambda_{|u|}]$
and connecting so that $g$ is non-decreasing continuous function.
Let $g$ be as
\begin{equation}
\label{equation: definition of g}
 g \left( l_u + \lambda_{|u|} \cdot y \right) =
 \begin{cases}
  (1-4y)l_u + 4y \cdot g \left( l_u + \frac{\lambda_{|u|}}{4} \right) 
  &
  0 \le y < \frac 1 4
  \\
  \frac{\lambda_{|u|}}{4} \left( 2y - \frac 1 2 - g_u \left( 2y - \frac 1 2 \right) \right) + l_u + \frac{\lambda_{|u|}}{2}
  &
  \frac 1 4 \le y \le \frac 3 4
  \\
  (4-4y) g \left( l_u + \frac 3 4 \lambda_{|u|} \right) + (4y-3)(l_u + \lambda_{|u|})
  &
  \frac 3 4 < y \le 1.
 \end{cases}
\end{equation}
for each $u \in \Sigma^*$ and $y \in [0,1]$, and $g(1) = 1$.

We show that the slope of $g$ is bounded from both above and below
by positive constants, which implies that $g$ is non-decreasing and 
$g$ and $g^-1$ have polynomial moduli of continuity.
Since $g(l_u)=l_u$ and 
$g(l_u+\frac{1}{4}\lambda_{|u|}) = l_u + \lambda_{|u|}(-\frac{1}{4}g_u(0) + \frac{1}{2})$,
\begin{equation}
 0 < \frac{1}{4}\lambda_{|u|}
 \le g \left( l_u+ \frac{1}{2} \lambda_{|u|} \right) - g(l_u)
 \le \frac{1}{2}\lambda_{|u|}.
\end{equation}
Hence the slope of $g$ in $[l_u, l_u + \frac{1}{4}\lambda_{|u|}]$ is 
greater than 1 and less than or equal to 2.
As $g(l_u+\frac{3}{4}\lambda_{|u|}) = l_u + \lambda_{|u|}(-\frac{1}{4}g_u(1) + \frac{3}{4})$ and
$g(l_u+\lambda_{|u|}) = l_u+\lambda_{|u|}$,
\begin{equation}
 0 < \frac{1}{4}\lambda_{|u|}
 \le g(l_u+\lambda_{|u|}) - g \left(l_u+ \frac 3 4 \lambda_{|u|} \right)
 \le \frac{1}{2}\lambda_{|u|}
\end{equation}
Hence the slope of $g$ in $[l_u + \frac{3}{4}\lambda_{|u|}, l_u + \lambda_{|u|}]$ is greater than 1 and less than or equal to 2.
For all $u \in \Sigma^*$ and $1/4 \le y' < y \le 3/4$,
\begin{equation}
0 < \frac{1}{4}(y - y') \le g(l_u+y) - g(l_u+y') \le \frac{3}{4}(y - y').
\end{equation}
Hence the slope of $g$ in $[l_u + \frac{1}{4}\lambda_{|u|}, l_u + \frac{3}{4}\lambda_{|u|}]$ 
is greater than or equal to $\frac{1}{4}$ and less than or equal to $\frac{3}{4}$.
Putting it all together, the slope of $g$ is greater than or equal to $\frac{1}{4}$ and less than or equal to $2$.

Let $t_u = l_u + \frac{1}{2}\lambda_{|u|}$ and $y_u$ satisfy that 
$l_u + \lambda_{|u|} \cdot y_u = g^{-1}(t_u)$, then
$2y_u - \frac{1}{2} - g_u (2y_u - \frac{1}{2}) = 0$.
Hence $2y_u - \frac{1}{2}$ is the fix point of $g_u$ and 
\begin{equation}
 y^*_u = \frac{2\left( g^{-1}(t_u) - l_u \right)}{\lambda_{|u|}} - \frac{1}{2}.
\end{equation}
This completes the proof of $\OpINV$ is $(\deltaboxINV, \deltabox)$-$\classPtwo$-$\redLmF$-complete.
\end{proof}


\end{document}
