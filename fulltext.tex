\documentclass[envcountsect,envcountsame,orivec,oribibl]{llncs}
\usepackage{mathtools}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{mypackage}
\usepackage{hyperref}
%\usepackage{amsthm}

% \newtheorem{theorem}{Theorem}[section]
% \newtheorem{lemma}[theorem]{Lemma}
% \newtheorem{corollary}[theorem]{Corollary}
% \theoremstyle{definition}
% \newtheorem{definition}[theorem]{Definition}
% \newtheorem{example}[theorem]{Example}
% \theoremstyle{remark}

\let\doendproof\endproof
\renewcommand\endproof{~\hfill\qed\doendproof}

\newcommand{\pcolon}{\mathpunct{\,:\subseteq}}

\title{Small complexity classes for computable analysis}
\author{Akitoshi Kawamura\qquad\qquad Hiroyuki Ota}
\institute{University of Tokyo}

\pagestyle{plain}
\begin{document}

\maketitle

\begin{abstract}
Type-two Theory of Effectivity (TTE) gives a concrete and general framework for 
Computable Analysis. 
To refine it to polynomial-time computability 
while keeping as much generality as possible, 
Kawamura and Cook recently proposed a modification to TTE using 
machines that have random access to an oracle and 
run in time depending on the ``size'' of the oracle. 
They defined type-two analogues of 
$\classP$, $\classNP$, $\classPSPACE$ 
and applied them to real functions and operators. 
We further refine their model and study computation below $\classP$: 
type-two analogues of 
the classes $\classL$, 
$\classNC$, 
and $\classP$-completeness under log-space reductions.
The basic idea is 
to use second-order polynomials as resource bounds, 
as Kawamura and Cook did, 
but we need to make some nontrivial (yet natural, as we will discuss) choices
when formulating small classes: 
we use a modification of the constant stack model 
of Aehlig, Cook and Nguyen for query tapes 
in order to achieve 
sufficient oracle accesses without interfering with space bounds; 
representations need to be chosen carefully, as 
computational equivalence between them is now finer; 
uniformity of circuits must be defined 
with varying sizes of oracles taken into account. 
As prototypical applications, 
we recast several facts (some in a stronger form than was known) 
about the complexity of numerical problems 
into our framework. 
\end{abstract}

\section{Introduction}

Computable Analysis 
\cite{ko1991complexity,weihrauch00:_comput_analy}
studies problems 
involving real numbers, real functions and other objects in analysis
from the viewpoint of computability on digital machines. 
Elements of uncountable sets (such as real numbers) are
represented through approximations (such as sequences of rational numbers)
and processed by Turing machines. 
Such approximation can be 
presented to the machine 
as infinite strings on the tape 
or as query-answering oracles (i.e., functions taking strings to strings), 
and this choice does not make much difference 
as long as we only discuss computability. 
But when we want to pay attention to bounds on time and space, 
Kawamura and Cook \cite{kawamura2012complexity} recently pointed out that 
it is more convenient to use oracles with random access, 
and moreover, to allow the running time 
to depend on the ``size'' of the oracle. 
Employing \emph{type-two complexity theory} and 
using \emph{second-order polynomials} to bound time and space, 
they formulated analogues of complexity classes 
$\classP$, $\classNP$, $\classPSPACE$ and 
showed some typical operators in analysis
to be in and complete for these classes. 
The basic definitions will be reviewed in Section~\ref{section: computable analysis}. 

One benefit of this was
a greater variety of objects for which we can define complexity. 
For example, with the second-order formulation
we obtain a canonical representation of the space $\classC [0, 1]$
of continuous real functions, 
so that we can discuss the complexity of an
operator $F \colon \classC [0, 1] \to \classC [0, 1]$. 
This extends the previously accepted notion of 
complexity of $f \in \classC [0, 1]$
(which could also be formulated in the infinite string model)
in a natural way, so that many known non-uniform results of the form
\begin{quote}
 if $f$ is in the complexity class $X$,
 then $F(f)$ is in the class $Y$, and \\
 there is $f$ in $X$ such that $F(f)$ is hard for
 the complexity class $Z$, 
\end{quote}
can now be transformed into a stronger, uniform statement of the form
\begin{quote}
 $F$ is in the complexity class $\mathcal Y$, and \\
 $F$ is hard for $\mathcal Z$ under the $\mathcal X$ reduction,
\end{quote}
where $\mathcal{X, Y, Z}$ are type-two classes analogous to ${X, Y, Z}$.

We continue their research and proceed down into $\classP$. 
In Section~\ref{section:small-classes}, 
we formulate and study analogues of 
$\classL$ (logarithmic space), 
$\classNC$ (poly-logarithmic depth circuits; efficiently parallelizable), 
and 
$\classP$-completeness (inherently sequential). 
While the fundamental idea, 
i.e.\ that of using of second-order polynomials as resource bounds, 
is common to \cite{kawamura2012complexity}, 
there are several choices that we need to make carefully
in implementing it, 
due to the subtleties pertaining to small complexity classes. 
In particular, 
we use a modified version of 
the \emph{constant stack machine} \cite{aehlig2007relativizing}, 
since it is consistent with relativized circuit complexity classes 
and it makes some elemental operation log-space computable.
Formulation of uniform circuit family
also requires careful consideration to 
accommodate function oracles. 

In Section~\ref{section:applications}, 
we apply this framework to several problems in analysis.
We present several examples of real functions and operators 
that are already essentially known (but non-trivially) to be, 
in our terminology, 
in $\classL$ and $\classNC$. 
We then take up
Hoover's theorem about fixed points of contractions \cite{hoover1991real}
and Ko's theorem about inverting a function \cite{ko1991complexity}, 
which both state hardness for $\classP$ in a sense, 
and reformulate them into our framework
as stronger uniform statements (as mentioned above).
The proofs are either relatively easy using known versions of the theorems
or obtained by minor modification of known argument; 
the benefit of having the result stated in the TTE framework 
is that it clarifies (through the choices of representations) 
which information exactly is needed for the computation 
(and how the needed amount of resource depends on it). 

%Chap.~\ref{chapter:computable-analysis} introduces Type-two Theory of Effectivity, the framework of Computable Analysis.
%We review basic concepts of TTE in Sect.~\ref{section:TTE} and
%Kawamura's extended framework for TTE in Sect.~\ref{section:TTF}.
%In Sect.~\ref{section:small-classes}, we introduce our new type-two classes
%$\classLtwo$ and $\classNCtwo$.
%We also define $\classPtwo$-completeness under reductions using these small classes.
%In Chap.~\ref{chapter:applications}, we investigate the complexity of some analytic problems.
%In Sect.~\ref{section:function}, we prove that finding roots of a polynomial 
%from coefficients is $\classNC$ computable.
%In Sect.~\ref{section:P-complete}, we show the $\classP$-completeness of 
%the inverse operation and the fix-point operation.
%In Sect.~\ref{section:differentiable}, we study the complexity of
%smooth differential equations.
%Most part in that section only depends on Sect.~\ref{section:TTE}
%since we mainly discuss in non-uniform way.
%We summarize this thesis and discuss about future works in Chap.~\ref{chapter:conclusion}.


\paragraph{Notation}
Let $\N$ and $\R$ denote the set of nonnegative integers and 
real numbers, respectively.

When we talk about polynomials as bounds on time or space, 
we tacitly assume that they are increasing functions. 

A {\em multi-valued function} (or {\em multi-function}) $F$ from $X$ to $Y$,
denoted $F \pcolon X \rightrightarrows Y$,
is a triple $(X, R, Y)$, where $R$ is a subset of $X \times Y$.
For $x \in X$, we write $F[x]$ for the set of $y \in Y$ such that $(x,y) \in R$.
The domain of $F$, denoted by $\dom F$, is the set of $x \in X$ such that 
$F[x]$ is not empty.
If $F[x]$ has only one element, we write $F(x)$ for the unique element.
We say $F$ is a {\em partial function} if $F[x]$ has exactly one element for all
$x \in \dom F$.
We call $F$ a {\em total function} or simply a {\em function} 
if $F$ is a partial function and $\dom F = X$.

% The composition of multi-functions $F \pcolon X \rightrightarrows Y$ and 
% $G \pcolon Y \rightrightarrows Z$, denoted $F \circ G$, is a multi-function
% $(X, R, Z)$ such that $(x, z) \in R$ if and only if there is $y \in Y$ 
% satisfying that $y \in F[x]$ and $z \in G[y]$.

\section{TTE with second-order polynomials}
\label{section: computable analysis}

We review the Type-two Theory of Effectivity (TTE), 
the framework for computable analysis, 
as extended by 
\cite{kawamura2012complexity}. 
We use string functions to 
encode objects, such as real numbers and real functions, 
and use \emph{oracle Turing machines} (henceforth just \emph{machines}) 
to work on them.
Sect.~\ref{section:TTF} defines polynomial-time computability on 
these string functions, 
and Sect.~\ref{subsection: representations} explains how to 
apply it to real functions (and other objects) through representations. 

\subsection{Type-two machines}
\label{section:TTF}

A (total) function $\phi \colon \Sigma^* \to \Sigma^*$ is \emph{length-monotone}
if $|\phi(u)| \le |\phi(v)|$ whenever $|u| \le |v|$.
We denote the set of length-monotone functions by $\LM$.
We write $M ^\phi (u)$ for the output string 
when a machine $M$ is given
$\phi \in \LM$ as oracle and $u \in \Sigma ^*$ as input.
Thus, we also regard $M^\phi$ as a function from strings to strings.

\begin{definition}
 A machine $M$ \emph{computes} a multi-function $A \pcolon \LM \rightrightarrows \LM$ if for any
 $\phi \in \dom A$, there is $\psi \in A[\phi]$ such that $M^\phi(u) = \psi(u)$ for all $u \in \Sigma^*$.
\end{definition}

The \emph{size} of $\phi \in \LM$, denoted $|\phi|$,
is a (non-decreasing) function from $\N$ to $\N$ defined by 
$|\phi|(|u|) = |\phi(u)|$.
This is well-defined since a length-monotone function maps 
strings of the same length to strings of the same length.
To define the class $\classFPtwo$ of 
multi-functions from $\LM$ to $\LM$ 
computable in polynomial time, 
we bound the running time by \emph{second-order polynomials} 
$P (\lvert \varphi \rvert) (\lvert x \rvert)$ 
in the sizes of the oracle $\phi$ and string $x$
given to the machine. 
A second-order polynomial $P (L) (n)$ 
is an expression built from the number $n$ 
using $\mathord+$, $\mathord\times$, 
\emph{and application of the function $L \colon \N \to \N$}; 
for example, 
$5 L (L (n) ^3 + n^2) + 2 n + 4$. 

\begin{definition}
 We write $\classFPtwo$ for the class of
 multi-functions from $\LM$ to $\LM$ 
 computed by a machine that runs
 in second-order polynomial time.
\end{definition}

We use bold letters (such as $\classFPtwo$) 
for classes of multi-functions from $\LM$ to $\LM$, 
as opposed to the usual complexity classes, such as $\classFP$, 
which we regard as consisting of multi-functions from $\Sigma ^*$ to $\Sigma ^*$.
The following is immediate. 

\begin{lemma}
\label{lemma: classFPtwo maps classFP to classFP}
 Functions in $\classFPtwo$ map 
 elements of $\classFP \cap \LM$ into $\classFP$.
\end{lemma}

For $\phi$, $\psi \in \LM$, 
we define $\langle \phi, \psi \rangle \in \LM$ by 
% \footnote{%
% The pairing function was
% defined erroneously in \cite{kawamura2012complexity} 
% without the delimiter $1$. 
% }
$\langle \phi, \psi \rangle(0u) = \phi(u) 10^{|\psi(u)|}$ and 
$\langle \phi, \psi \rangle(1u) = \psi(u) 10^{|\phi(u)|}$
(we pad $0$s to make $\langle \phi, \psi \rangle$ length-monotone).
We write $\langle \phi, \psi, \theta \rangle$ 
for $\langle \phi, \langle \psi, \theta \rangle \rangle$, and so on.
We also write $\langle \phi, u \rangle$, etc., for 
$\phi \in \LM$ and a string $u \in \Sigma ^*$, 
by identifying $u$ with the constant function in $\LM$ with value $u$. 

\subsection{Representations}
\label{subsection: representations}

A \emph{representation} of a set $X$ 
is a partial function $\gamma$ from $\LM$ to $X$
such that for every $x \in X$ there is $\phi$ with $\gamma (\phi) = x$.
We call $\phi$ a {\em $\gamma$-name} of $x$
if $x = \gamma (\phi)$.

\begin{definition}
\label{definition: computation wrt representation}
\begin{enumerate}
\item 
Let $C$ be a class of multi-functions from $\Sigma ^*$ to $\Sigma ^*$, 
and let $\gamma$ be a representation of a set $X$. 
We write \emph{$\gamma$-$C$} for the set of $x \in X$
that have a $\gamma$-name in $C$.
\item 
Let $\mathcal C$ be a class of multi-functions from $\LM$ to $\LM$,
and $\gamma$ and $\delta$ be representations of sets $X$ and $Y$, respectively.
A multi-function $A \pcolon X \rightrightarrows Y$
is in $(\gamma, \delta)$-$\mathcal C$ if 
the following multi-function $
\delta^{-1} \circ A \circ \gamma \pcolon \LM \rightrightarrows \LM
$ is in $\mathcal C$: 
\begin{equation}
 (\delta^{-1} \circ A \circ \gamma)[\phi] = 
  \begin{cases}
   \{\psi \in \dom \delta \mid \delta(\psi) \in A[\gamma(\phi)] \}
   & 
   \text{if } \phi \in \dom \gamma, 
   \\ 
   \emptyset 
   &
   \text{otherwise.}
  \end{cases}
\end{equation}
\end{enumerate}
\end{definition}

For real numbers and real functions,
we use representations $\rhoR$ and $\deltabox$, 
defined as follows \cite{kawamura2012complexity}. 
We first introduce an encoding of dyadic numbers.
For each $n \in \N$, let $\D_n$ denote the set of strings of the form
\begin{equation}
 sx/1\!\underbrace{00\dots0}_{n},
\end{equation}
where $s$ is the sign and $x \in \{0,1\}^*$.
We write $\D$ for the union $\bigcup _n \D _n$.
We regard $u \in \D$ as a fraction of binary numbers, 
and write $u$ also for the number it encodes. 

We define the representation~$\rhoR$ of $\R$ as follows: 
$\phi \in \LM$ is a $\rhoR$-name of $x \in \R$ 
if $\phi(0^i) \in \D$ and $\lvert \phi(0^i) - x \rvert \le 2^{-i}$
for all $i \in \N$.
We write $\rhoR|^{[0,1]}$ for the representation of the interval $[0, 1]$ 
obtained by restricting $\rhoR$.
The class $(\rhoR|^{[0,1]},\rhoR)$-$\classFPtwo$ 
coincides with 
the polynomial-time computable functions by Ko~\cite{ko1991complexity}. 

We call $\mu \colon \N \to \N$ a {\em modulus of continuity} 
of $f \in \classC [0, 1]$ 
if 
for all $n \in \N$ and $x$, $y \in [0,1]$ with
$|x - y| \le 2^{-\mu(n)}$, 
we have $|f(x) - f(y)| \le 2^{-n}$ .
It is not hard to verify the following. 

\begin{lemma}
 \label{lem:type1representation}
 A real function is in $(\rhoR|^{[0,1]},\rhoR)$-$\classFPtwo$ if and only if
 it has a polynomial modulus of continuity 
 and there is a function $\phi \in \classFP$ such that 
 \begin{equation}
   \label{eq:computation on rational points}
  |\phi(d, 0^n) - f(d)| \le 2^{-n} 
 \end{equation}
 for all $d \in \D \cap [0,1]$ and $n \in \N$. 
\end{lemma}

The following representation $\deltabox$ of $\classC[0,1]$ 
is inspired by this. 
For a non-decreasing function $\mu \colon \N \to \N$, 
we write $\overline \mu \in \LM$ for the 
function that maps each string $u$ to $0^{\mu(|u|)}$.
A $\deltabox$-name of $f \in \classC[0,1]$ is 
a pair $\langle \overline{\mu}, \phi \rangle$
of $\phi \in \LM$ and $\mu \colon \N \to \N$
such that 
$\mu$ is a modulus of continuity of $f$
and $\phi$ satisfies \eqref{eq:computation on rational points}.
Lemma~\ref{lem:type1representation} implies that
$(\rhoR|^{[0,1]},\rhoR)$-$\classFPtwo$ equals
$\deltabox$-$\classFP$. 

\section{Small type-two classes}
\label{section:small-classes}

In this section, we introduce type-two complexity classes
corresponding to log-space $\classL$ and circuit complexity $\classNC$
based on the framework we reviewed in the previous section.
We also define $\classP$-completeness under log-space reductions.

\subsection{Logarithmic space}
There are several non-equivalent definitions of 
relativized log-space computation
\cite{aehlig2007relativizing,buss1988relativized,ladner1976relativization,wilson1988measure}.
Here, we define type-two log-space computation 
by extending the {\em stack model with constant height} 
by Aehlig, Cook and Nguyen \cite{aehlig2007relativizing} to the 
function-oracle model.
We choose this model because it is consistent with relativized circuit complexity classes, 
and it can ask nested queries, that is, queries depending on answers to previous queries.
See also the comments on Theorems \ref{theorem:inclusion} and \ref{theorem:apply-is-L-computable}.

We consider an oracle Turing machine $M$ 
with a stack of query tapes and an answer tape.
The machine $M$ can write a symbol on the top query tape, or 
\emph{push} a new query tape on the top of the stack (and start writing on it).
When the machine issues a query, the stack is \emph{popped} automatically; 
that is, 
if the string on the query tape at the top of the stack was $u$, 
the oracle $\phi$ writes the string $\phi (u)$ on the answer tape, 
and at the same time the top query tape is removed from the stack. 
We put the restriction that the height of the stack of a machine is less than 
some constant for all inputs and oracles.
We also assume that 
the answer tape is erased after each push operation.

The use of a stack of query tapes and its restriction to constant height 
is common to Aehlig, Cook and Nguyen \cite{aehlig2007relativizing}. 
As we are dealing with function oracles, 
our model has some new features, namely 
the introduction of the answer tape and 
the restriction that it is erased automatically on every push operation. 

This erasure of the answer tape
ensures that the nested depth of queries is restricted to a constant.
Without this restriction, a log-space constant-stack machine relative to 
a function oracle $\phi$ could compute polynomial-times composition
of $\phi$ if $|\phi|(n) = n$.
On the other hand, there is a function $\phi \in \LM$ such that $|\phi|(n) = n$
and polynomial-times composition of $\phi$ is not in $\classNC$ relative to $\phi$ \cite{aehlig2007relativizing}.
Hence, the inclusion $\classL \subseteq \classNC$ would not relativize.

\begin{definition}
 A (constant-stack) machine runs in (second-order) \emph{logarithmic space}
 if there is a second-order polynomial $P$ such that, 
 given oracle $\phi \in \LM$ and string $u \in \Sigma^*$, 
 it visits at most $\log(P(|\phi|)(|u|))$ cells
 in the work tape.
 We write $\classFLtwo$ for the set of multi-functions%
\footnote{%
We could also define a class $\classLtwo$, 
analogous to $\classPtwo$ in \cite{kawamura2012complexity}, 
of multi-functions whose values are functions in $\LM$ 
that are $\{0, 1\}$-valued, 
but we will not use such classes in this paper. 
}
 from $\LM$ to $\LM$ 
 computed by such a machine.
\end{definition}

\begin{lemma}
\label{lemma:Ltwo-maps-L-to-L}
 Functions in $\classFLtwo$ map 
 elements of $\classFL \cap \LM$
 into $\classFL$.
\end{lemma}

% \begin{proof}
% For all $\phi \in \classFL$, the size of $\phi$ is bounded by some polynomial,
% hence second-order logarithm collapses to first-order logarithm.
% Since $\classFL$ is low for itself ($\classFL^\classFL = \classFL$), 
% functions computed by log-space constant-stack machines with $\classFL$ oracle are in $\classFL$.
% \end{proof}

\subsection{Circuit complexity classes}

To discuss type-two circuit complexity classes,
we consider circuit families with oracle gates.
Let $n, m \in \N$ and $L \colon \N \to \N$ be a non-decreasing function.
An \emph{$n$-input $m$-output circuit with size-$L$ oracle gates} is a circuit with
$n$ inputs and $m$ outputs consisting of the standard logical gates 
plus oracle gates, 
where each oracle gate with $k$ inputs has $L(k)$ outputs.
Formally, 

\begin{definition}[Oracle circuits]
Let $n, m \in \N$ and $L \colon \N \to \N$ be a non-decreasing function.
A \emph{$n$-input $m$-output circuit with size-$L$ oracle gates} is 
a labeled directed acyclic graph with $n$ sources and $m$ sinks.
All vertices except the sources are labeled with $\NOT$, $\OR$, $\AND$ 
or $\phi _i$, where $i \in \N$.
The in-degree of a vertex labelled $\NOT$ is $1$, and
a vertex that is labelled $\phi _i$ and has in-degree $k$ 
satisfies $i < L(k)$.
Each logic gate performs the logical operation on its inputs, 
and $\phi_i(x) = 1$ if and only if the $i$th bit of $\phi(x)$ is $1$.
The \emph{size} of $C$ is the number of gates.
The \emph{depth} of $C$ is the length of the longest path in $C$.
For an input $x \in \{0, 1\}^*$, an oracle $\phi \in \LM$, 
and a $|x|$-input $m$-output circuit $C$ with size-$|\phi|$ oracle gates, 
we write $C^\phi(x)$ for the $m$-bit output of $C$.
\end{definition}

To discuss circuit families computing multi-functions from $\LM$ to $\LM$,
we index circuits not only by the input size but also by the size of oracle gates.
A {\em circuit family $(C_{L,n})_{L,n}$} is a set of circuits, 
indexed by numbers $n \in \N$ and non-decreasing functions $L \colon \N \to \N$,
such that $C_{L, n}$ is an $n$-input circuit with size-$L$ oracle gates.

\begin{definition}
 We say that a circuit family $(C_{L,n})_{L,n}$ 
\emph{computes} a multi-function 
 $A \pcolon \LM \rightrightarrows \LM$ if for all $\phi \in \dom A$, 
 there is $\psi \in A[\phi]$ satisfying $\psi(x) = C_{|\phi|, |x|}^\phi(x)$
 for all $x \in \Sigma^*$.
\end{definition}

Now we want to define the type-two complexity class analogous to $\classNC$.
To define it, we choose not $\classNC^i$ but $\classAC^i$ 
only for the sake of simplicity.

A circuit family $(C_{L,n})_{L,n}$ is \emph{(second-order) polynomial size}
if there is a second-order polynomial $P$ satisfying
the size of $C_{L,n}$ is bounded by $P(L)(n)$ 
for all $n \in \N$ and non-decreasing functions
$L \colon \N \to \N$.

\begin{definition}
 For each $k \in \N$, 
 we write $\classFACtwo^k$ for the class of 
 multi-functions from $\LM$ to $\LM$ computed by
 a polynomial-size circuit family $(C_{L,n})_{L,n}$ such that
 there is a second-order polynomial $P$ such that 
 the depth of $C_{L,n}$ is bounded by $\log^k(P(L)(n))$ 
 for all $n \in \N$ and non-decreasing
 $L \colon \N \to \N$.
 We write $\classFNCtwo = \bigcup_{k \in \N} \classFACtwo^k$.
\end{definition}

Next, we want to define log-space uniformity in oracle circuit families.
Since an oracle circuit family is indexed by the size of the input and the oracle gate,
a function computing (descriptions of) circuits needs both sizes.

\begin{definition}[uniformity]
A circuit family $(C_{L,n})_{L,n}$ is \emph{$\classLtwo$-uniform} if there is a function $A \in \classFLtwo$ 
such that for all $n \in \N$ and non-decreasing $L \colon \N \to \N$, 
the string $A (\overline L) (0^n)$ is (a description of) $C_{L,n}$. 
%% 「description」とは？？？
\end{definition}

Hereafter, we assume log-space uniformity on all (type-one and type-two) 
circuit complexity classes, so we write just ``uniform'' or omit ``$\Luniform$''.

\begin{theorem}
\label{theorem:P-equals-L-uniform-P-poly}
A multi-function $A$ from $\LM$ to $\LM$ is computed by a polynomial-size
uniform circuit family if and only if $A \in \classFPtwo$.
\end{theorem}

\begin{proof}
 It is obvious that machines can compute the output of
 polynomial-size uniform circuits in polynomial time.
 The if part is proved in the similar argument to the proof of
 $\classP \subseteq \classP\!\text{/poly}$.
 For each multi-function $A \in \classFPtwo$, there is an oracle machine $M$
 computing $A$ whose head movements do not depend on the input $x$ or oracle
 $\phi$ but only depend on the input length $|x|$ and oracle size $|\phi|$.
 This property enable a polynomial-size uniform circuit family to simulate $M$.
\end{proof}

The relativization using the stack model by Aehlig, Cook and Nguyen preserves
the inclusion of non-relativized classes
$\classAC^0 \subseteq \classL \subseteq \classAC^1 \subseteq \classNC$.
Since we define the type-two log-space class by extending the stack model,
the analogous inclusions can be shown for our type-two classes
by a similar argument. 

\begin{theorem}
\label{theorem:inclusion}
$ \classFACtwo^0
 \subseteq \classFLtwo 
 \subseteq \classFACtwo^1
 \subseteq \classFNCtwo
 \subseteq \classFPtwo$. 
\end{theorem}

\begin{proof}
 The first inclusion can be proved similarly
 to $\classAC^0 \subseteq \classL$.
 The second inclusion can be proved by an argument similar to
 $\text{cs}\classL(\alpha) \subseteq \classAC^1(\alpha)$
 \cite{aehlig2007relativizing}.
 The third inclusion is immediate.
 The last inclusion follows from Theorem~\ref{theorem:P-equals-L-uniform-P-poly}.
\end{proof}


The following lemma states that type-two $\classLtwo$ uniformity respects
$\classL$ uniformity.

\begin{lemma}
\label{lemma: respects uniformity}
 Let $(C_{L,n})_{L,n}$ be a (second-order) polynomial-size $\Luniform$ oracle circuit family
 and $(D_n)_n$ be a (first-order) polynomial-size $\classL$-uniform circuit family.
 A circuit family given by replacing oracle gates in $(C_{L,n})_{L,n}$ with
 $(D_n)_n$ is $\classL$-uniform.
\end{lemma}

\begin{corollary}
\label{lemma: type-one and type-two circuit classes}
\begin{enumerate}
 \item Functions in $\classFACtwo^i$ 
       map elements of $\classFAC^j \cap \LM$ 
       into $\classFAC^{i+j}$.
 \item Functions in $\classFNCtwo$
       map elements of $\classFNC \cap \LM$ 
       into $\classFNC$.
\end{enumerate}
\end{corollary}

See appendix for proofs of 
Lemmas \ref{lemma: respects uniformity} and 
\ref{lemma: type-one and type-two circuit classes}.

\subsection{Reductions and completeness}

The following logspace reductions $\redLmF$, $\redLW$, $\redLB$ are 
analogues of the polynomial-time reductions 
$\redmF^2$, $\redW^2$ in Kawamura and Cook~\cite{kawamura2012complexity}
and the ``many-one reduction'' in Beame et al.~\cite{beame1995relative}. 
Note that $A \redLmF B$ implies $A \redLW B$ and $A \redLB B$. 

\begin{definition}
Let $A$ and $B$ be multi-functions from $\LM$ to $\LM$.
\begin{itemize}
 \item $A$ is \emph{many-one log-space reducible} to $B$, 
       denoted $A \redLmF B$,
       if there are functions $r, s, t \in \classFLtwo$ such that 
       for all $\phi \in \dom A$,
       we have $s(\phi) \in \dom B$ and 
       for each $\theta \in B[s(\phi)]$, 
       the function that maps $x \in \Sigma^*$ to $r(\phi)(x, \theta(t(\phi)(x)))$
       is in $A[\phi]$.
 \item $A$ is \emph{Weihrauch log-space reducible} to $B$,
       denoted $A \redLW B$,
       if there are functions $r, s \in \classFLtwo$ such that 
       for all $\phi \in \dom A$,
       we have $s(\phi) \in \dom B$ and 
       for each $\theta \in B[s(\phi)]$, 
       we have $r(\langle \phi, \theta \rangle) \in A[\phi]$.
 \item $A \redLB B$ 
if there are functions $r, s, t \in \classFLtwo$ such that 
for all $\phi \in \dom A$,
the function~$\sigma$ that maps $y \in \Sigma ^*$ to $s (\phi) (x, y)$
belongs to $\dom B$ 
and for each $\theta \in B [\sigma]$, 
the function that maps $x \in \Sigma^*$ 
to $r(\phi)(x, \theta(t(\phi)(x)))$ is in $A[\phi]$.
\end{itemize}
\end{definition}

For a class $\mathcal{C}$ of multi-functions from $\LM$ to $\LM$
and a reduction $\leq$, 
we say that $B \pcolon \LM \rightrightarrows \LM$ is 
\emph{$\mathcal{C}$-$\leq$-hard} if $A \leq B$ for all $A \in \mathcal{C}$,
and $B$ is \emph{$\mathcal{C}$-$\leq$-complete} 
if $B$ is $\mathcal{C}$-$\leq$-hard and in $\mathcal{C}$.

The reduction $\redLB$ is stronger than $\redLmF$ in that 
$s$ can read the input string $x$ when answering queries from $B$.
In many applications to analysis, 
the (thus easier) proof of $\redLB$-hardness 
already seems to capture the essential complexity of the operator
(e.g.~Theorem~\ref{theorem:P-hard-g_u} in our case), 
but we need the stronger hardness (with $\redLmF$ or $\redLW$)
if we want to derive a non-uniform version just from the statement
(see the next lemma, which does not hold for
$\redLB$; cf.~\cite[Lemma~3.6]{kawamura2012complexity}). 

For $F \subseteq \LM$, 
define the multi-function $\bigcup F \pcolon \Sigma ^* \rightrightarrows \Sigma ^*$ by
$(\bigcup F) [x] = \{\, f(x) \mid f \in F \,\}$.
The following lemma (see appendix for a proof)
will help us in Sect.~\ref{section:P-complete} to show that 
our uniform statements ($\classFPtwo$-$\redLmF$-hardness of an operation)
imply the known non-uniform results 
(existence of an $\classFP$-hard output). 

\begin{lemma}
\label{lemma:P-complete}
Let $B$ be a $\classFPtwo$-$\redLmF$-complete multi-function.
There is $\psi \in \dom B \cap \classFL$ such that
 $\bigcup (B[\psi])$ is $\classFP$-$\le^\classL_{\mathrm{mF}}$-complete.
\end{lemma}

The following partial function $\probDTIMEtwo \pcolon \LM \to \LM$ 
is a standard complete problem: 
$\dom \probDTIMEtwo$ consists of $\langle M, \overline \mu, \phi \rangle$
such that $M$ is (the program of) a machine, 
$\mu \colon \N \to \N$ is non-decreasing, 
$\phi \in \LM$, 
and $M^\phi(x)$ stops in $\mu(|x|)$ steps for all $x \in \Sigma^*$; 
for such $\langle M, \overline \mu, \phi \rangle$, 
we define $\probDTIMEtwo(\langle M, \overline \mu, \phi \rangle)(x)$ to be 
the output of the computation $M^\phi(x)$.

\begin{lemma}
\label{lemma: probDTIMEtwo}
 $\probDTIMEtwo$ is $\classFPtwo$-$\redLmF$-complete.
\end{lemma}

% We define a partial function  $\probCVPtwo \pcolon \LM \to \LM$ as follows:
% $\dom \probCVPtwo$ is the set of $\langle (C_n)_n, \phi \rangle$
% such that $C_n$ is (the description of) a circuit with $n$ inputs 
% (and multiple outputs)
% consisting of $\AND$, $\OR$, $\NOT$ and oracle gates, 
% for which $\phi \in \LM$ has the right size.
% For $\probCVPtwo(\langle (C_n)_n, \phi \rangle)(x) = C^\phi_{|x|}(x)$.

% \begin{lemma}
%  $\probCVPtwo$ is $\classFPtwo$-$\redLmF$-complete.
% \end{lemma}

% \begin{proof}
% Similar to Theorem~\ref{theorem:P-equals-L-uniform-P-poly}.
% \end{proof}

\subsection{Representations}
\newcommand{\transL}{\preceq_\classLtwo}

Let $\gamma$ and $\delta$ be representations of $X$ and $Y$, respectively.
Definition~\ref{definition: computation wrt representation} 
tells us when 
a point $x \in X$ is in $\gamma$-$\classFL$ or $\gamma$-$\classFNC$, 
and when a multi-function $A \pcolon X \rightrightarrows Y$ is in
$(\gamma, \delta)$-$\classFLtwo$ or
$(\gamma, \delta)$-$\classFNCtwo$. 
We also define hardness under representations: 
$x$ is $\gamma$-$C$-$\le$-\emph{hard} if
$\bigcup(\gamma^{-1}[x])$ is $C$-$\le$-hard,
where $\gamma^{-1}[x]$ is the set of $\gamma$-names of $x$; 
and $A$ is $(\gamma, \delta)$-$\classFPtwo$-$\le$-\emph{hard}
if $\delta^{-1} \circ A \circ \gamma$ 
(see Definition~\ref{definition: computation wrt representation}) 
is $\classFPtwo$-$\le$-hard.
The following facts
about translation between representations are
analogous to \cite{kawamura2012complexity}. 

\begin{definition}
Let $\gamma$ and $\delta$ be two representations of a set $X$.
We write $\gamma \transL \delta$ if
there is a function $F \in \classFLtwo$ \emph{translating} $\gamma$-names
into $\delta$-names, that is, 
$F (\phi) \in \dom \delta$ and $\delta(F(\phi)) = \gamma (\phi)$ 
for all $\phi \in \dom \gamma$.
\end{definition}

\begin{lemma}
 Let $\gamma$ and $\gamma'$ be representations of a set $X$, 
 $\delta$ and $\delta'$ be representations of a set $Y$.
 If $\gamma \transL \gamma'$ and $\delta \transL \delta'$, then 
\begin{enumerate}
\item 
$(\gamma', \delta)$-$\mathcal C \subseteq (\gamma, \delta')$-$\mathcal C$, 
for $\mathcal{C} = \classFLtwo$, $\classFNCtwo$ or $\classFPtwo$; 
\item 
a $(\gamma, \delta')$-$\classFPtwo$-$\redLW$-hard multi-function is
$(\gamma', \delta)$-$\classFPtwo$-$\redLW$-hard.
\end{enumerate}
\end{lemma}

Although this shows that $\redLW$-hardness is 
more stable and perhaps natural 
than $\redLmF$-hardness, 
we will state some of our hardness results in Sect.~\ref{section:applications}
using $\redLmF$, 
in the interest of proving stronger statements
(and deriving the existing non-uniform counterparts as corollaries
through the following lemma). 

The following lemma is the version of 
Lemmas~\ref{lemma: classFPtwo maps classFP to classFP}, 
\ref{lemma:Ltwo-maps-L-to-L}, 
\ref{lemma: type-one and type-two circuit classes} and 
\ref{lemma:P-complete} for represented spaces, 
and follows easily from them. 

\begin{lemma}
\label{lemma:p-comp-maps-l-to-p-comp}
 Let $\gamma$ and $\delta$ be representations of sets $X$ and $Y$, respectively.
\begin{enumerate}
\item
 A partial function in $(\gamma, \delta)$-$\mathcal C$
 maps all elements of $\gamma$-$C$ in its domain into $\delta$-$C$, 
 where $\mathcal C$ is $\classFLtwo$, $\classFNCtwo$, or $\classFPtwo$ 
 and $C$ is the corresponding type-one class. 
\item \label{enumi:p-comp-maps-l-to-p-comp}
 A $(\gamma, \delta)$-$\classFPtwo$-$\redLmF$-complete partial function 
 maps some element of $\gamma$-$\classFL$ 
 to a $\delta$-$\classFP$-$\redmF^\classL$-complete element of $Y$.
\end{enumerate}
\end{lemma}

\section{Applications}
\label{section:applications}

In Sect.~\ref{section:function}, 
we show some examples of real functions and operators 
that are in $\classFLtwo$ and $\classFNCtwo$ (under suitable representations). 
In Sect.~\ref{section:P-complete}, we show the $\classP$-completeness of 
the inverse operation and the fix-point operation.

\subsection{Within $\classFLtwo$ and $\classFNCtwo$}
\label{section:function}

We start with real numbers and real functions, 
using the representation $\rhoR$
(see Sect.~\ref{subsection: representations}). 
Ko's class of
\emph{log-space real functions} in $\classC[0,1]$ 
\cite{ko1991complexity} 
coincides with our $(\rhoRunit, \rhoR)$-$\classFLtwo$, 
despite our choice of constant-stack log-space machine 
while Ko uses the obvious log-space oracle Turing machine 
with no stack.
This is because, 
when computing approximation of $f(x)$ under $\rhoR$-names, 
a machine can get enough information about $x \in [0,1]$ in one query.
Ko also defines the class of $\classNC$ real functions in $\classC[0,1]$
as $\deltabox$-$\classFNC$ in our terminology 
\cite{ko1991complexity},
which easily equals $(\rhoRunit, \rhoR)$-$\classFNCtwo$.
The $\classNC$-real functions from $\R$ to $\R$ defined by Hoover \cite{hoover1991real}
are exactly those in $(\rhoR, \rhoR)$-$\classFNCtwo$.

\begin{example}
 The binary addition and the binary multiplication are
 $([\rhoR, \rhoR], \rhoR)$-$\classFLtwo$-computable.
\end{example}

\begin{example}
The circle ratio $\pi$ is in $\rhoR$-$\classFL$ because the series
\begin{equation}
 \pi = \sum_{k=0}^\infty \frac{1}{16^k} 
  \left( \frac{4}{8k+1} - \frac{2}{8k+4} - \frac{1}{8k+5} - \frac{1}{8k+6} \right)
\end{equation}
converges fast enough, 
so that a $2 ^{-n}$-approximation to $\pi$ can be obtained by adding up 
an appropriate number $k = \mathrm O (n)$ of terms. 
This computation of approximate partial sum involves 
polynomially many multiplications, additions, and divisions on rationals, 
and each of these operations can be performed in logarithmic space
by Chiu, Davida and Litow~\cite{chiu2001division}.
\end{example}

% \begin{lemma}
%  The exponential function restricted to $[0,1]$
%  is in $(\rhoRunit, \rhoR)$-$\classFLtwo$.
% \end{lemma}
% Since the series $\exp(t) = \sum_n x^n / n!$ converges fast enough,
% a $2^{-m}$-approximation of $\exp(t)$ for $t \in [0,1]$ can be computed
% by polynomially many multiplications, additions, and divisions on rationals. 

% On the other hand, without the restriction on the domain, $\exp$ is not 
% even in $(\rhoR, \rhoR)$-$\classFPtwo$, 
% because it grows too fast. 

\begin{example}
The sine function $\sin \colon \R \to \R$ is
in $(\rhoR, \rhoR)$-$\classFLtwo$.
To see this, note that 
the Taylor series of $\sin$ also converge fast enough,
so it is log-space computable if restricted to $[-4, 4]$.
The multi-function that computes from $t$
any $x \in [-4, 4]$ with $x \equiv t \bmod 2 \pi$ is
in $(\rhoR, \rhoR|^{[-4,4]})$-$\classFLtwo$, 
because division is log-space computable 
and $\pi \in \rhoR$-$\classFL$. 
Combining these, $\sin \in (\rhoR, \rhoR)$-$\classFLtwo$.
\end{example}

The following states that $\deltabox$ 
is the weakest representation that makes function evaluation 
logspace computable, 
and gives evidence that 
$\deltabox$ is the natural choice (relative to $\rhoR$)
as a basic representation of $\classC [0, 1]$. 
It can be proved similarly to the analogous theorem for $\classFPtwo$ 
\cite{kawamura11:_funct_space_repres_and_polyn_time_comput}. 

\begin{theorem}
 \label{theorem:apply-is-L-computable}
 Let $\delta$ be a representation of $\classC[0, 1]$.
 $\OpApply$ is in $([\delta, \rhoRunit], \rhoR)$-$\classFLtwo$ if
 and only if $\delta \transL \deltabox$.
\end{theorem}

Note that, 
if we had defined $\classFLtwo$ with the obvious relativized machine with one query tape,
$\classFLtwo$ would be either too weak 
to have $\OpApply \in ([\deltabox,\rhoR], \rhoR)$-$\classFLtwo$ or
too strong to be a subset of $\classFNCtwo$,
depending on whether or not the machine is allowed to look at the answer tape while writing queries.
% Our extension of the constant stack model is the weakest
% such that both Theorem~\ref{theorem:apply-is-L-computable} and 
% $\classFLtwo \subseteq \classFNCtwo$ true.

In the rest of Sect.~\ref{section:function}, 
we reformulate in our terminology a known result that 
informally reads
``the roots of a complex polynomial can be found in $\classNC$.'' 

We write $P_n$ for the set of degree-$n$ monic 
polynomials (i.e.\ the leading coefficient is $1$) with complex coefficients.
We write $\OpPolyRoot(p)$ for the multiset of all the roots of $p \in P_n$, that is, $p(x) = \prod_{z \in \OpPolyRoot(p)} (x - z)$. 
Neff first showed the following theorem, which says that 
approximating the roots of polynomial
with integer (or rational, equivalently) coefficients is in $\classFNC$.
We write $|p|$ for the maximum absolute value of coefficients in $p$.

\begin{theorem}
[NC polynomial root isolation \cite{neff1994specified}]\label{theorem:neff1994}
There is an algorithm $A$ such that,
for any choice of integers $n$, $m$, $k$, and a polynomial $p \in P_n$
with $|p| \le 2^m$,
$A$ computes $k$-digit approximation to the roots of $p$ 
in at most $C \log^e(n + m + k)$ parallel steps, 
using at most $D(n + m + k)^f$ processors, where $C, D, e, f$ are positive
constants which are independent of $n$, $m$, and $k$.
\end{theorem}

Later Pan showed that approximating the roots of a polynomial
with complex rational coefficients is in $\classFNC$ \cite{pan1995optimal}.
Neff and Reif showed a similar result and they also discuss
the modulus of continuity of finding roots \cite{neff1996efficient}.

\begin{theorem}
[{\cite[Theorem 2.1]{neff1996efficient}}]
\label{neff1996modulus}
 Let $f$ and $g$ be monic polynomials of the same degree $n$,
 and let $|f| \le 2^m$.
 For each $k \in \N$, 
 if $|f - g| \le 2^{\lceil n(k + m + \log n + 3)\rceil}$, then
 $d(\OpPolyRoot(f), \OpPolyRoot(g)) \le 2^{-k}$. 
\end{theorem}

% They regard these two results ensure that $\classFNC$-computability
% of finding roots of a polynomial with complex coefficients.%%??????
% In our framework, we can combine these two results by stating 
% $\classFNCtwo$-computability under suitable representations.

These can be recast into our framework by specifying 
representations for polynomials and multisets of complex numbers as follows.
We represent a complex number by a pair of $\rhoR$-names,
i.e., $
 \rho_\C (\langle \phi, \psi \rangle) 
= 
 \rhoR (\phi) + \sqrt{-1} \cdot \rhoR (\psi)
$.  We define the representation $\rho_{P_n}$ of 
$P _n$ as follows: 
$\phi = \langle \phi _0, \ldots, \phi _{n - 1} \rangle \in \LM$ 
is a $\rho_{P_n}$-name of $p \in P_n$ if 
$\phi _0$, \ldots, $\phi _{n - 1}$ are 
$\rho_{\C}$-names of $a _0$, \ldots, $a _{n - 1}$, respectively, 
with $p(x) = x^n + a_{n-1}x^{n-1} + \dots + a_0$.
Define the representation $\rho_{P_*}$ of all monic polynomials by
$\rho_{P_*}(\langle 0^n, \phi \rangle) = \rho_{P_n}(\phi)$.
Define the representation $\rhoCSet$ for finite multisets of complex numbers 
as follows:
$\phi \in \LM$ is a $\rhoCSet$-name of a multiset $S$ if 
for each $m \in \N$, 
we have $\phi(0 ^m) = ( a_1, b_1, a_2, b_2, \dots, a_n, b_n )$
with $a_1, b_1, \dots, a_n, b_n \in \D_m$
such that 
$d(S, \{a_1 + b_1 \sqrt{-1}, \dots, a_n + b_n \sqrt{-1}\}) \le 2^{-m}$, 
where the distance between two multisets is defined as $
 d (\{z_1, \dots, z_n\}, \{z'_1, \dots, z'_n\}) 
= 
 \min_{\sigma} \max_{j = 1, \ldots, n}|z_j - z'_{\sigma(j)}|
$, with $\sigma$ ranging over all permutations on $\{1, \ldots, n\}$. 

%We can also represent multisets $S$ as vectors $z \in \C^n$
%such that $S = \{z\}$.
%More formally we define representation $\rhoCSet'$ as
%$\rhoCSet'(\phi) = \{z\}$ if $\rho_{\C^*}(\phi) = (z_1, \dots, z_n)$.
%It is easy to see that $\rhoCSet' \le_\classFLtwo \rhoCSet$,
%but the following lemma says they are not equivalent even under computability.
%\begin{lemma}
% Identity function on multisets is not $(\rhoCSet, \rhoCSet')$-computable.
%\end{lemma}
%This means that $\rhoCSet'$ is more informative than $\rhoCSet$.
%\paragraph{Finding polynomial roots is $\classFNCtwo$-computable}

\begin{theorem}
 \label{theorem:finding-roots-is-in-NC}
 $\OpPolyRoot$ is in $(\rho_{P_*}, \rhoCSet)$-$\classFNCtwo$.
\end{theorem}

% \begin{corollary}
%  $\OpPolyRoot$ is $(\rho_{P_n}, \rhoCSet)$-$\classFNCtwo$-computable.
% \end{corollary}

\begin{proof}
This is immediate by the following algorithm
using the above-cited facts:
Given $k \in \N$ and a $\rho_{P_n}$-name of $p \in P_n$, 
compute a polynomial $q \in {P_n}$ with complex rational coefficients
satisfying $|p - q| \le 2^{\lceil n((k+1) + m + \log n + 3)\rceil}$.
By Theorem~\ref{neff1996modulus}, the difference between 
the roots of $p$ and $q$ is at most $2^{-(k+1)}$.
Output approximate roots of $q$ with precision $2^{-(k+1)}$ 
computed by the algorithm by Neff and Reif, or Pan,
which are $2^{-k}$-approximations of roots of $p$.
\end{proof}

\subsection{$\classPtwo$-complete operations}
\label{section:P-complete}

Here we state and prove uniform versions of 
Hoover's and Ko's $\classP$-hardness results 
about operators on real functions. 
As mentioned in the introduction, 
this is only possible with our type-two formulation of complexity classes. 

\subsubsection{Inverting a function}

Fix $a$, $b \in \R$ with $a < b$. 
Let $M$ be the set of one-to-one functions $f \in \classC[0,1]$
whose range is $[a,b]$.
We define the function $\OpINV \colon M \to \classC [a, b]$ 
by saying that $\OpINV (f) = f ^{-1}$ is the inverse function of $f$. 

Ko proved the following non-uniform theorem about the complexity of inversion.
Recall that Ko's polynomial-time and log-space computability of a real function
is equivalent to our $(\rhoRunit, \rhoR)$-$\classFPtwo$ and $(\rhoRunit, \rhoR)$-$\classFLtwo$. 

\begin{theorem}
[{\cite[Corollary 4.7 and Theorem 4.18]{ko1991complexity}}]
\label{theorem: ko inversion}
\begin{enumerate}
\item \label{enumi:ko1991-4.7}
Assume that $f \in M$ is polynomial-time computable. 
If $f^{-1}$ has a polynomial modulus of continuity, 
then $f^{-1}$ is polynomial-time computable.
\item \label{enumi:ko1991-4.18}
There is a log-space computable $f \in M$
such that $f^{-1}$ has a polynomial modulus of continuity
but $f^{-1}$ is not log-space computable
unless $\classP = \classL$.
\end{enumerate}
\end{theorem}

We define a representation $\deltaboxINV$ of $M$ as follows:
$\deltaboxINV(\langle \phi, \overline{\mu} \rangle) = f$ 
if and only if $\phi$ is a $\deltabox$-name of $f$ 
and $\mu$ is a modulus of continuity of $f^{-1}$.
We add a modulus of continuity of $f^{-1}$ to $\deltabox$
since without this information, there is no upper bound on 
the complexity of the inverse operation, 
as the following fact \cite[Theorem 4.4]{ko1991complexity} shows: 
for any recursive $x \in [0, 1]$, 
there exists a strictly increasing function $f \in \classC[0, 1]$ 
such that $f$ is polynomial-time computable and $x = f^{-1}(0)$.

The following theorem is the uniform version of Theorem~\ref{theorem: ko inversion}. 
Part~\ref{enumi:ko1991-4.7} of Theorem~\ref{theorem: ko inversion} 
follows from this and Lemma~\ref{lemma: classFPtwo maps classFP to classFP}.
Part~\ref{enumi:ko1991-4.18} follows from this theorem and Lemma~\ref{lemma:p-comp-maps-l-to-p-comp}.\ref{enumi:p-comp-maps-l-to-p-comp}.

\begin{theorem}
 \label{theorem:INV-is-P-complete}
 $\OpINV$ is $(\deltaboxINV, \deltabox)$-$\classFPtwo$-$\redLmF$-complete.
\end{theorem}

This will be proved in the appendix, 
using 
Theorem~\ref{theorem:P-hard-g_u} below. 

\subsubsection{Fixed points of contractions}

A function $g \colon K \to \R$ on a set $K \subseteq \R$
is called $q$-\emph{Lipschitz}, for $q > 0$, 
if $
\lvert g (x) - g (y) \rvert \leq q \cdot \lvert x - y \rvert
$ for all $x$, $y \in K$. 
A \emph{contraction} on $K$ is 
a function $g \colon K \to \R$ which is $q$-Lipschitz for some $q < 1$
and whose values are in $K$. 
The Banach fixpoint theorem states that 
a contraction has a fixed point and it is unique. 
Hoover's theorem about the complexity of computing the fixed point
of a contraction can be written in our terminology as follows:

\begin{theorem}
[{\cite[Theorem 4.5]{hoover1991real}}]
\label{theorem:hoover1991-4.5}
 There is a function $f \colon \R \to \R$ in $(\rhoR, \rhoR)$-$\classFNCtwo$
 whose restriction $f|_{[2k, 2k+1]}$ is a contraction for each $k \in \N$ and
 which has the following property: 
 $\classNC = \classP$ if and only if 
 there is a function (from strings to strings) in $\classFNC$ mapping 
 a pair of a number $k \in \N$ (written in binary) and the string $0^n$
 to a $2^{-n}$-approximation of the 
 fixed point of $f |_{[2k, 2k + 1]}$. 
\end{theorem}

For our formulation in TTE, 
let $C$ be the set of contractions on $[0, 1]$. 
We define its representation $\deltaboxCM$ by saying that 
a \emph{$\deltaboxCM$-name} of $g \in C$
is a pair $\langle \phi, q \rangle$ of 
a $\deltabox$-name $\phi \in \LM$ of $g$ 
and a dyadic number $q \in \D$ such that $g$ is $q$-Lipschitz. 
Let $\OpCMFix \colon C \to \R$ be the function
taking each contraction on $[0, 1]$ to its fixed point.

\begin{theorem}
\label{theorem:P-hard-g_u}
$\OpCMFix$ is $(\deltaboxCM, \rhoR)$-$\classFPtwo$-$\redLB$-complete. 
It remains so even if $\dom \OpCMFix$ is restricted to contractions 
that are $1/2$-Lipschitz.
\end{theorem}

See appendix for the proof that Theorem~\ref{theorem:P-hard-g_u} 
implies Theorem~\ref{theorem:hoover1991-4.5}. 

\bibliographystyle{plain}
\bibliography{bibliography}

\clearpage
\appendix
\section{Postponed proofs}

\subsection{Properties of circuits with oracles}

\begin{proof}[Lemma~\ref{lemma: respects uniformity}]
 Let $A \colon \LM \to \LM$ be a function computing the description of $(C_{L,n})_{L,n}$,
 $B \colon \Sigma^* \to \Sigma^*$ be a function computing the description of $(D_n)_n$, and
 $L \colon \N \to \N$ be the size of oracle $(D_n)_n$, i.e.
 the function mapping $n$ to the output length of $D_n$.
 The function $A(\overline{L})$ is in $\classFL$ since $\overline{L} \in \classFL$ and $A \in \classFLtwo$.
 Since given $A(\overline{L})$ and $B$ as oracles,
 computing the description of the circuit family given by replacing oracle
 gates in $(C_{L,n})_{L,n}$ with $(D_n)_n$ is log-space computable
 and $\classFL$ is low for itself ($\classFL^\classFL = \classFL$),
 it is log-space computable.
\end{proof}

\begin{proof}[Lemma~\ref{lemma: type-one and type-two circuit classes}]
The second statement immediately follows from the first statement.
Let $A$ be a function in $\classFACtwo^i$ and $(C_{L,n})_{L,n}$ be a circuit
family computing $A$ with $\log^i$ depth.
For all $\phi \in \classFAC^j \cap \LM$, 
the circuit family $(C^\phi_{|\phi|,n})_n$ is (first-order) polynomial size and its depth is $O(\log^i(n))$,
since there is a polynomial $p$ satisfying $|\phi|(n) \le p(n)$.
Let $(D_n)_n$ is a circuit family computing $\phi$ whose depth is $O(\log^j(n))$.
Replacing oracle gates in $(C^\phi_n)_n$ by $(D_n)_n$, 
we get a circuit family with polynomial size and $\log^{i+j}(n)$ depth
that computes $A(\phi)$.
\end{proof}

\subsection{$\classFPtwo$-complete problems}

\begin{proof}[Lemma~\ref{lemma:P-complete}]
Let $A \colon \LM \to \LM$ be the constant function mapping each $\phi \in \LM$ to \emph{Circuit Value Problem} ($\probCVP$), which is $\classFP$-complete function (in the usual sense).
Since $\probCVP \in \classFP$, $A \in \classFPtwo$.
Let $r, s, t \in \classFLtwo$ be functions which reduces $A$ to $B$
as the definition of $\redLmF$.
Choose any $\phi \in \classFL$, and it follows from Lemma~\ref{lemma:Ltwo-maps-L-to-L}
that $r(\phi), s(\phi), t(\phi) \in \classFL$.
Let $\psi = s(\phi)$, then $r(\phi)$ and $s(\phi)$ give the reduction that
$A(\phi) \redmF^\classL \cup (B[\psi])$.
Since $\probCVP$, equal to $A(\phi)$, is $\classFP$-$\redmF^\classL$-complete,
so is $\cup (B[\psi])$.
\end{proof}

\begin{proof}[Lemma~\ref{lemma: probDTIMEtwo}]
 For each $A \in \classFPtwo$, 
 there is a polynomial-time machine $M$ 
 and a second-order polynomial $P$ 
 such that $M$ computes $L$ and $P$ is its time bound. 
 Then $\probDTIMEtwo(s(\phi))(t(\phi)(u)) = M^\phi (u)$, 
 where 
 $s, t \in \classFLtwo$ are given by 
 $s(\phi) = \langle M, \overline{P(\mu)}, \phi \rangle$ and 
 $t(\phi)(u) = u$.
\end{proof}

\subsection{Function inversion and Banach fixed points}

\begin{proof}[Computability part of Theorem~\ref{theorem:INV-is-P-complete}]
We will prove hardness in Section~\ref{section:proofs-of-theorems}.
In the following, we will show that, 
given $f$ and $x$, 
it is easy to compute $f^{-1}(x)$ by using the binary search algorithm.

Suppose that a $\deltaboxINV$-name of a one-to-one function $f$ in $\classC [0, 1]$ is given. 
Since a modulus~$p$ of continuity of $f ^{-1}$ is given by this $\deltaboxINV$-name of $f$,
we only show how to compute a function $\phi$ such that 
$|f^{-1}(d) - \phi(0^n, d)| \le 2^{-n}$ for all $d \in \D \cap [a, b]$ and $n \in \N$.

Since $f$ is one to one, $f$ is either increasing or decreasing. 
We assume that $f$ is increasing (the other case is similar).
Given $d \in \D \cap [a, b]$, 
we compute a sequence  $a_0, b_0, a_1,b_1, \dots, a_{3n}, b_{3n}$ of rational numbers as follows.
Let $a_0 = 0$, $b_0 = 1$.
For each integer $i \le 3n-1$,
let $c_i = (a_i+b_i)/2$ and $d_i = \phi_f(c_i, 0^{p(i+2)})$.
If $d \ge d_i$, then $a_{i+1} = (3a_i+b_i)/4$ and $b_{i+1} = b_i$. 
Otherwise, let $a_{i+1} = a_i$ and $b_{i+1} = (a_i+3b_i)/4$.

We prove $f(a_i) \leq d \leq f(b_i)$ by induction on $i$.
In the case $i = 0$, $f(a_i) = f(0) \le d \le f(1) = f(b_i)$.
In the case $i=j+1$, if $d \ge d_j$ then $d \le f(b_j) \le f(b_{j+1})$ and
\begin{equation}
 d \ge d_j \ge f(c_n) - 2^{-p(j+2)} > f(a_{j+1}),
\end{equation}
where the last inequality follows from the fact that $c_j - a_{j+1} = (3/4)^i/4 > 2^{-(j+2)}$ and $p$ is a modulus of continuity of $f^{-1}$.
If $d \le d_j$ then $f(a_{j+1}) = f(a_j) \le d$ and 
\begin{equation}
 d \le d_j \le f(c_n) + 2^{-p(j+2)} < f(b_{j+1}).
\end{equation}

Let $\phi(0^n, d) = a_{3n}$.
Since $|b_{3n} - a_{3n}| = (3/4)^{3n} \le 2^{-n}$ and
$a_{3n} \le f^{-1}(d) \le b_{3n}$,
$|f^{-1}(d) - \phi(0^n, d)| \le 2^{-n}$
\end{proof}

\begin{proof}
[Theorem~\ref{theorem:hoover1991-4.5}]
 Let $A \colon \LM \to \LM$ be the constant function mapping each $\phi \in \LM$ to $\probCVP$, which is $\classFP$-complete function.
 Since  $A$ is in $\classFPtwo$ and $\OpCMFix$ is $(\deltaboxCM, \rhoR)$-$\classFPtwo$-$\redLB$-complete, $A \redLB (\rhoR^{-1} \circ \OpCMFix \circ \deltaboxCM)$.
 Let $r,s,t \in \classFLtwo$ be the reduction from $A$ to $\OpCMFix$,
 and $\phi$ be some function in $\classFL$.
 Then, $r(\phi)$, $s(\phi)$, and $t(\phi)$ are in $\classFL$ and
 $s(\phi)(u, \cdot)$ is a $\deltaboxCM$-name of a contraction on $[0,1]$ 
 for each $u \in \Sigma^*$.
 Let $(g_u)_u$ be a family of contractions on $[0,1]$
 such that $s(\phi)(u, \cdot)$ is $\deltaboxCM$ name of $g_u$.
 Define $f$ as follows: for each $u \in \Sigma^*$ and $y \in [0, 1]$,
 \begin{equation}
  \label{eq:def-f}
 f(t_u + y) = t_u + g_u(y)
 \end{equation}
 where $t_u = \overline{1u0}-2$, 
 and $f$ is connected linearly in other interval.

 We show that $f$ meets the conditions in Theorem~\ref{theorem:hoover1991-4.5}.
 This $f$ is in $(\rhoR, \rhoR)$-$\classFNCtwo$ since 
 $|f(x) - f(x')| \le 3|x-x'|$ and $s(\phi)$ is in $\classFNC$.
 Since $g_u$ is a contraction, so is $f|_{[2n, 2n+1]}$.
 If $\classNC = \classP$,
 the fix-point of $f$ on $[2n, 2n+1]$ 
 is in $\classFNC$ since $\classFPtwo$-computable function 
 $\OpCMFix$ maps $\classFP$-computable functions into $\classFP = \classFNC$.
 The string function $r(\phi), t(\phi) \in \classFL$ many-one reduces
 $\probCVP$ to the fix-points of $(g_u)_u$.
 Hence $\classNC = \classP$ if fix-points of $f$ on $[2k, 2k+1]$ is $\classFNC$-computable.
\end{proof}

\subsubsection{$\classFPtwo$-$\redLB$-hardness of the fix-point operation}

\begin{proof}[Theorem~\ref{theorem:P-hard-g_u}]
 We show that for each $\psi \in \dom \probDTIMEtwo$
 (see Lemma~\ref{lemma: probDTIMEtwo} for the problem $\probDTIMEtwo$),
 there is a log-space computable family of contractions $(g_u)_u$ whose
 Lipschitz constant is less than $1/2$,
 and for each $u \in \Sigma^*$, $\probDTIMEtwo(\psi)(u)$ is log-space 
 computable from the fix point of $g_u$.
 Since this implies that $\probDTIMEtwo \redLB \OpCMFix$ and $\probDTIMEtwo$
 is $\classFPtwo$-$\redLmF$-hard, $\OpCMFix$ is 
 $(\deltaboxCM, \rhoR)$-$\classFPtwo$-$\redLB$-complete.

 Let $\psi \in \probDTIMEtwo$ and $\langle M, \phi, \bar \mu \rangle = \psi$.
 Let $S_i$ be the snapshot of $M^\phi(u)$ at $i$th step, then the sequence
 \begin{equation}
  S_1, S_2, \dots, S_{\mu(|u|)}.
 \end{equation}
 is the computation path of $M^\phi(u)$.
 We assume that the encoding of snapshots satisfies that 
 for some second-polynomial $P$, for all machines $M$, time functions $\mu$ 
 and inputs $u$, $|S_0| = \cdots = |S_{\mu(|u|)}| = L(\mu)(|u|)$
 regardless of the oracle $\phi$.
 Let $m = L(\mu)(|u|)$.


 For each $u \in \Sigma^*$, we define $g_u \in \classC[0,1]$ as
 a piecewise linear function with $2\mu(|u|)$ points
 $y = l_0 (=0), l_1, \dots, l_{\mu(|u|)}, r_{\mu(|u|)}, \dots, r_0(=1)$,
 where
\begin{alignat}{2}
 \label{equation: l_k}
 l_k 
 &
 = \sum_{1 \le i \le k} (2^m+\overline{S_i}) \cdot 2^{-i(m+4)+2} 
 &
 = 0.01S_100\ 01S_200 \cdots 01S_k00,
 \\
 \label{equation: r_k}
 r_k
 &
 = l^\psi_k + 2^{-i \cdot (m+4)}
 &
 = 0.01S_100\ 01S_200 \cdots 01S_k01.
\end{alignat}
 Let $S_{\mu(|u|)+1} = S_{\mu(|u|)}$ and
 define $l_{\mu(|u|)+1}$ and $r_{\mu(|u|)+1}$ as
 \eqref{equation: l_k} and \eqref{equation: r_k}.
 For each $k = 0, \dots, \mu(|u|)$,
 we define $g_u$ as
 \begin{align}
 g_u(l_k) &= l_{k+1},
 &
 g_u(r_k) &= r_{k+1}.
 \end{align}

 We show that $g_u \in \classC[0,1]$ is a contraction whose Lipschitz constant
 is less than $1/2$.
 Since $l_{k+1} - l_{k} = (2^m+\overline{S_{k+1}}) \cdot 2^{-(k+1)(m+4)+2} $
 and $r_{k+1} - r_{k} = (2^{m+4} - 2^{m+2} - 2^2 \cdot \overline{S_{k+1}} - 1)
 \cdot 2^{-(k+1)(m+4)} $,
\begin{align}
 \left|\frac{g_u(l_{k+1}) - g_u(l_k)}{l_{k+1} - l_k} \right| 
 &
 \le 2^{-m-3} \le \frac 1 2
 \\
 \left|\frac{g_u(r_{k+1}) - g_u(r_k)}{r_{k+1} - r_k} \right| 
 &
 \le 2^{-m-3} \le \frac 1 2
 \\
 \left|\frac{g_u(r_{\mu(|u|)}) - g_u(l_{\mu(|u|)})}{r_{\mu(|u|) - l_{\mu(|u|)}}} \right| 
 &
 = 2^{-m-4} \le \frac 1 2.
\end{align}
 So $|g_u(x) - g_u(y)| \le \frac 1 2 |x-y|$.

 The fix point $y^*_u$ of $g_u$ is between $l_{\mu(|u|)}$ and $r_{\mu(|u|)}$ 
 since $l_k < l_{k+1} = g_u(l_k)$ and $r_k > r_{k+1} = g_u(r_k)$.
 Let $\hat y^*_u$ be a $2^{-(m+2)\mu(|u|)}$-approximation of $y^*_u$, then
\begin{equation}
 \lfloor \hat y^*_u \cdot 2^{(m+2)\mu(|u|)-2} + 2^{-2}\rfloor  \bmod 2^m
  =
  \overline{S_{\mu(|u|)}}.
\end{equation}
 Hence, the output of $M^\phi(u)$ is log-space computable from 
 $u \in \Sigma^*$ and a $2^{-(m+2)\mu(|u|)}$-approximation $y^*_u$, and so is
 $\probDTIMEtwo(\psi)(u)$.
\end{proof}


\subsubsection{Proof of Theorem \ref{theorem:INV-is-P-complete}}
\label{section:proofs-of-theorems}

We show the $\classFP$-$\redLmF$-hardness 
by putting all $(g_u)_u$ into one real function $g \in \dom F$
such that for each $u \in \Sigma^*$ there is 
$t_u$ in $\rhoR$-$\classFL$ 
and the fix point of $g_u$ is log-space computable from $h(t_u)$.

\begin{proof}
[Theorem~\ref{theorem:INV-is-P-complete}]
Let $L \in \classPtwo$ and $\psi \in \dom L$.
Let $r, s, t \in \classFLtwo$ be functions reducing $L$ to $\OpCMFix$
as Theorem~\ref{theorem:P-hard-g_u}.
Let
\begin{align}
 \lambda_n &= 2^{-2n-1},
 &
 l_u & = 1 - 2^{-|u|} + \bar u \cdot \lambda_{|u|}.
\end{align}

A unique fix point of a contraction $f(x)$ is computable as
$f^{-1}(x)$ where non-decreasing function $f$ is defined as $f(x) = x - g(x)$.
We define $g$ by transforming $g_u$ in this way, putting them into the
interval $[l_u + \frac{1}{4}\lambda_{|u|}, l_u + \frac{3}{4}\lambda_{|u|}]$
and connecting so that $g$ is non-decreasing continuous function.
Let $g$ be as
\begin{equation}
\label{equation: definition of g}
 g \left( l_u + \lambda_{|u|} \cdot y \right) =
 \begin{cases}
  (1-4y)l_u + 4y \cdot g \left( l_u + \frac{\lambda_{|u|}}{4} \right) 
  &
  0 \le y < \frac 1 4
  \\
  \frac{\lambda_{|u|}}{4} \left( 2y - \frac 1 2 - g_u \left( 2y - \frac 1 2 \right) \right) + l_u + \frac{\lambda_{|u|}}{2}
  &
  \frac 1 4 \le y \le \frac 3 4
  \\
  (4-4y) g \left( l_u + \frac 3 4 \lambda_{|u|} \right) + (4y-3)(l_u + \lambda_{|u|})
  &
  \frac 3 4 < y \le 1.
 \end{cases}
\end{equation}
for each $u \in \Sigma^*$ and $y \in [0,1]$, and $g(1) = 1$.

We show that the slope of $g$ is bounded from both above and below
by positive constants, which implies that $g$ is non-decreasing and 
$g$ and $g^-1$ have polynomial moduli of continuity.
Since $g(l_u)=l_u$ and 
$g(l_u+\frac{1}{4}\lambda_{|u|}) = l_u + \lambda_{|u|}(-\frac{1}{4}g_u(0) + \frac{1}{2})$,
\begin{equation}
 0 < \frac{1}{4}\lambda_{|u|}
 \le g \left( l_u+ \frac{1}{2} \lambda_{|u|} \right) - g(l_u)
 \le \frac{1}{2}\lambda_{|u|}.
\end{equation}
Hence the slope of $g$ in $[l_u, l_u + \frac{1}{4}\lambda_{|u|}]$ is 
greater than 1 and less than or equal to 2.
As $g(l_u+\frac{3}{4}\lambda_{|u|}) = l_u + \lambda_{|u|}(-\frac{1}{4}g_u(1) + \frac{3}{4})$ and
$g(l_u+\lambda_{|u|}) = l_u+\lambda_{|u|}$,
\begin{equation}
 0 < \frac{1}{4}\lambda_{|u|}
 \le g(l_u+\lambda_{|u|}) - g \left(l_u+ \frac 3 4 \lambda_{|u|} \right)
 \le \frac{1}{2}\lambda_{|u|}
\end{equation}
Hence the slope of $g$ in $[l_u + \frac{3}{4}\lambda_{|u|}, l_u + \lambda_{|u|}]$ is greater than 1 and less than or equal to 2.
For all $u \in \Sigma^*$ and $1/4 \le y' < y \le 3/4$,
\begin{equation}
0 < \frac{1}{4}(y - y') \le g(l_u+y) - g(l_u+y') \le \frac{3}{4}(y - y').
\end{equation}
Hence the slope of $g$ in $[l_u + \frac{1}{4}\lambda_{|u|}, l_u + \frac{3}{4}\lambda_{|u|}]$ 
is greater than or equal to $\frac{1}{4}$ and less than or equal to $\frac{3}{4}$.
Putting it all together, the slope of $g$ is greater than or equal to $\frac{1}{4}$ and less than or equal to $2$.

Let $t_u = l_u + \frac{1}{2}\lambda_{|u|}$ and $y_u$ satisfy that 
$l_u + \lambda_{|u|} \cdot y_u = g^{-1}(t_u)$, then
$2y_u - \frac{1}{2} - g_u (2y_u - \frac{1}{2}) = 0$.
Hence $2y_u - \frac{1}{2}$ is the fix point of $g_u$ and 
\begin{equation}
 y^*_u = \frac{2\left( g^{-1}(t_u) - l_u \right)}{\lambda_{|u|}} - \frac{1}{2}.
\end{equation}
This completes the proof of $\OpINV$ is $(\deltaboxINV, \deltabox)$-$\classPtwo$-$\redLmF$-complete.
\end{proof}


\end{document}
